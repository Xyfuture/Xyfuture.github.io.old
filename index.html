<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Xyfuture&#39;s home">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Xyfuture&#39;s home">
<meta property="article:author" content="Xyfuture">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Xyfuture's home</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Xyfuture's home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/Program-week12-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/14/Program-week12-homework/" itemprop="url">Program-week12-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-14T23:31:30+08:00">
                2020-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/14/Program-week11-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/14/Program-week11-homework/" itemprop="url">Program-week10-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-14T23:31:04+08:00">
                2020-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week11-homework"><a href="#week11-homework" class="headerlink" title="week11-homework"></a>week11-homework</h1><h2 id="A-必做题11-1"><a href="#A-必做题11-1" class="headerlink" title="A - 必做题11-1"></a><a href="https://vjudge.net/problem/计蒜客-T1065" target="_blank" rel="noopener">A - 必做题11-1</a></h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/14/xr3MEeZvVwOFDjC.png" alt=""></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这是一道简单的模拟题,首先得了解高中学的概率知识,明白$(1+k)^t$这样一个增长公式然后可以用模拟的方法一年一年的模拟解出问题,也可以推一个的数学公式,直接算出来,这里采取模拟的方法</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> n;</span><br><span class="line">    <span class="keyword">float</span> m=<span class="number">200</span>;</span><br><span class="line">    <span class="keyword">float</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f%f"</span>,&amp;n,&amp;k);<span class="comment">//浮点</span></span><br><span class="line">    k = k/<span class="number">100</span>;<span class="comment">//小数</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">float</span> total = m;</span><br><span class="line">    <span class="keyword">float</span> salary = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(salary-total&lt;<span class="number">0.000001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        salary =i*n;<span class="comment">//收入</span></span><br><span class="line">        total = m*<span class="built_in">pow</span>((<span class="number">1</span>+k),i<span class="number">-1</span>);<span class="comment">//房价</span></span><br><span class="line">        <span class="keyword">if</span>(i++&gt;<span class="number">21</span>)<span class="comment">//大于20年</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">21</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>难度不大,但是得理清楚年份之间的关系,第一年房价是原价</p>
<h2 id="B-必做题11-2"><a href="#B-必做题11-2" class="headerlink" title="B - 必做题11-2"></a><a href="https://vjudge.net/problem/计蒜客-T3176" target="_blank" rel="noopener">B - 必做题11-2</a></h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/14/c67wD98zqyoA2pR.png" alt="image-20200514234019695"></p>
<p>输入输出都是一个数字组成的矩阵</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>题目本身也是模拟,这个考察了数组的下标的运用,通过下标的转换实现数组的转换</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="comment">// int mid[22][22];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> data[i][j]!=ans[i][j]; <span class="comment">//不动</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> data[n-j<span class="number">-1</span>][i]!=ans[i][j];  <span class="comment">//顺时针90</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> data[n-i<span class="number">-1</span>][n-j<span class="number">-1</span>]!=ans[i][j]; <span class="comment">//顺时针180</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> data[j][n-i<span class="number">-1</span>]!=ans[i][j]; <span class="comment">//顺时针270</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> t)</span>  <span class="comment">//调用dec</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span>(dec(t,i,j))<span class="comment">//dec比较的是不等,一旦不等直接退出</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="comment">// memset(mid,0,sizeof(mid));</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ans[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(rotate(i+<span class="number">1</span>))<span class="comment">//四种旋转</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本题考查数组的使用,通过下标的转换就能实现在不同方向上对数组矩阵的遍历</p>
<h2 id="C-必做题11-3"><a href="#C-必做题11-3" class="headerlink" title="C - 必做题11-3"></a><a href="https://vjudge.net/problem/计蒜客-T1111" target="_blank" rel="noopener">C - 必做题11-3</a></h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/14/JlkDPV3mwMSNefj.png" alt="image-20200514234609345"></p>
<p>经典凯撒密码</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>将读入的字符一个一个进行判断是大写字母,ascii-5转换为明文输出,不是大写字母直接输出</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">202</span>] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((data[t++] = getchar())!=<span class="string">'\n'</span>);<span class="comment">//读取,也可以getline</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]&gt;=<span class="string">'A'</span>&amp;&amp;data[i]&lt;=<span class="string">'Z'</span>)<span class="comment">//大写字母</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,(data[i]+<span class="number">26</span><span class="number">-5</span>-<span class="string">'A'</span>)%<span class="number">26</span>+<span class="string">'A'</span> );</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//其他</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>考察点主要在字符串读取和简易处理上</p>
<h2 id="D-必做题11-4"><a href="#D-必做题11-4" class="headerlink" title="D - 必做题11-4"></a><a href="https://vjudge.net/problem/CodeForces-1138A" target="_blank" rel="noopener">D - 必做题11-4</a></h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/14/2YnumKQszb5vBgA.png" alt=""></p>
<p>求取相同元素区间的长度</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这个和之前一个求相同元素长度区间的类似,只不过这个需要判断两个区间长度</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,data+i);</span><br><span class="line">    <span class="keyword">int</span> siz  e[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//记录一段中1和2的个数</span></span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;<span class="comment">//输出的最大值</span></span><br><span class="line">    <span class="keyword">int</span> pre = data[<span class="number">0</span>];<span class="comment">//前一个变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(data[i] == pre)<span class="comment">//如果现在的等于前一个,计数增加</span></span><br><span class="line">            size[data[i]]++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = size[<span class="number">1</span>]&lt;size[<span class="number">2</span>]?size[<span class="number">1</span>]:size[<span class="number">2</span>];<span class="comment">//1-&gt;2 or 2-&gt;1交界点</span></span><br><span class="line">            <span class="keyword">if</span>(cur&gt;Max)<span class="comment">//更新</span></span><br><span class="line">                Max = cur;</span><br><span class="line">            pre = data[i];<span class="comment">//新的pre</span></span><br><span class="line">            size[pre] = <span class="number">1</span>;<span class="comment">//计数</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> cur = size[<span class="number">1</span>]&lt;size[<span class="number">2</span>]?size[<span class="number">1</span>]:size[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(cur&gt;Max)</span><br><span class="line">        Max = cur;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Max*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>似乎这类问题挺多的,之前写的版本可能会re,不要在for中使用while</p>
<h2 id="E-选做题11-1-东东与-ATM"><a href="#E-选做题11-1-东东与-ATM" class="headerlink" title="E - 选做题11-1 东东与 ATM"></a><a href="https://vjudge.net/problem/POJ-1276" target="_blank" rel="noopener">E - 选做题11-1 东东与 ATM</a></h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/15/tOr4maQVojHGK23.png" alt=""></p>
<p>这道题是一道多重背包,而且需要使用二进制拆分进行优化才可过</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/Program-week9-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/Program-week9-homework/" itemprop="url">Program-week9-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-29T21:28:23+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week9-homework"><a href="#week9-homework" class="headerlink" title="week9-homework"></a>week9-homework</h1><h2 id="A-咕咕东的目录管理器"><a href="#A-咕咕东的目录管理器" class="headerlink" title="A - 咕咕东的目录管理器"></a><a href="https://vjudge.net/problem/Kattis-directorymanagement" target="_blank" rel="noopener">A - 咕咕东的目录管理器</a></h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><p><img src="https://i.loli.net/2020/05/04/CG9PtmcWDFk8oEp.png" alt=""></p>
<p>题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.</p>
<p>首先我们设计文件树的存储(为啥用树?题目直接说了文件树 … )</p>
<p>这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map\<string,int\>存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标</p>
<p>剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector\<string\> ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.</p>
<p>下面讲解各个命令:</p>
<p>首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标</p>
<p>mkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history</p>
<p>rm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history</p>
<p>cd: 遇到”..”直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history</p>
<p>sz: 直接输出allNodes</p>
<p>ls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个</p>
<p>tree: 该命令是比较难实现的,需要一定的记忆化<br>首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> nodeName;<span class="comment">//文件名</span></span><br><span class="line">    <span class="keyword">int</span> father;<span class="comment">//父节点下标</span></span><br><span class="line">    <span class="keyword">int</span> allNodes;<span class="comment">//总的孩子个数+1 sz使用</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ftree;<span class="comment">//tree命令使用的数组,前5个和后5个</span></span><br><span class="line">    <span class="keyword">int</span> change;<span class="comment">//ftree是否发生改变</span></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; children;<span class="comment">//按字典序存孩子节点的文件名和下标</span></span><br><span class="line">    treeNode(<span class="built_in">string</span> name,<span class="keyword">int</span> father,<span class="keyword">int</span> allNodes,<span class="keyword">int</span> change):nodeName(name),father(father),allNodes(allNodes),change(change)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    treeNode()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> command;</span><br><span class="line">    <span class="keyword">int</span> pwd;</span><br><span class="line">    <span class="keyword">int</span> newDir;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;treeNode&gt; nodes;<span class="comment">//所有节点的数组,下标就是这里的</span></span><br><span class="line"><span class="built_in">stack</span>&lt;cmd&gt; history;<span class="comment">//操作命令历史记录</span></span><br><span class="line"><span class="keyword">int</span> curPosi;<span class="comment">//当前操作的位置的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushForward</span><span class="params">(<span class="keyword">int</span> posi,<span class="keyword">int</span> num)</span><span class="comment">//从posi开始上溯</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    nodes[posi].allNodes +=num;<span class="comment">//更新allNode</span></span><br><span class="line">    nodes[posi].change = <span class="number">1</span>;<span class="comment">//ftree要重新改变</span></span><br><span class="line">    nodes[posi].ftree.clear();<span class="comment">//清空(也可以不删)</span></span><br><span class="line">    <span class="keyword">if</span>(nodes[posi].father == posi)<span class="comment">//到达根节点</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//继续更新父节点</span></span><br><span class="line">        pushForward(nodes[posi].father,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> newDirName;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;newDirName;</span><br><span class="line">    <span class="keyword">if</span> (nodes[curPosi].children.find(newDirName) != nodes[curPosi].children.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    nodes.push_back(treeNode(newDirName,curPosi,<span class="number">1</span>,<span class="number">1</span>));<span class="comment">//插入新节点</span></span><br><span class="line">    <span class="keyword">int</span> newPosi = nodes.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    pushForward(curPosi,<span class="number">1</span>);<span class="comment">//向上更新</span></span><br><span class="line">    nodes[curPosi].children[newDirName] =newPosi;<span class="comment">//孩子</span></span><br><span class="line">    history.push(&#123;<span class="string">"mkdir"</span>,curPosi,newPosi&#125;);<span class="comment">//更新history</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> delDirName;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;delDirName;</span><br><span class="line">    <span class="keyword">if</span> (nodes[curPosi].children.find(delDirName) == nodes[curPosi].children.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ptr =nodes[curPosi].children[delDirName];</span><br><span class="line">    <span class="keyword">int</span> cnt = nodes[ptr].allNodes;</span><br><span class="line">    nodes[curPosi].children.erase(delDirName);<span class="comment">//只删除孩子,不删除nodes</span></span><br><span class="line">    history.push(&#123;<span class="string">"rm"</span>,curPosi,ptr&#125;);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> newDirName;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;newDirName;</span><br><span class="line">    <span class="keyword">if</span>(newDirName == <span class="string">".."</span>)<span class="comment">//father</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nodes[curPosi].father == curPosi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR\n"</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> newPosi = nodes[curPosi].father;</span><br><span class="line">        history.push(&#123;<span class="string">"cd"</span>,curPosi,newPosi&#125;);</span><br><span class="line">        curPosi = newPosi;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nodes[curPosi].children.find(newDirName) == nodes[curPosi].children.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newPosi = nodes[curPosi].children[newDirName];</span><br><span class="line">    history.push(&#123;<span class="string">"cd"</span>,curPosi,newPosi&#125;);</span><br><span class="line">    curPosi = newPosi;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = nodes[curPosi].allNodes;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childSize = nodes[curPosi].children.size();</span><br><span class="line">    <span class="keyword">if</span>(childSize == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"EMPTY\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (childSize &lt;=<span class="number">10</span>)<span class="comment">//10个之内</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nodes[curPosi].children)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i.first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"\n";</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator front = nodes[curPosi].children.begin();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator tail = nodes[curPosi].children.end();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++,front++)<span class="comment">//前5个</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(*front).first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// tail--;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"...\n"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++,tail--);<span class="comment">//后5个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++,tail++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;(*tail).first&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"\n";</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(history.size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    cmd oldCmd = history.top();</span><br><span class="line">    history.pop();</span><br><span class="line">    <span class="keyword">if</span>(oldCmd.command == <span class="string">"mkdir"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[oldCmd.pwd].children.erase(nodes[oldCmd.newDir].nodeName);<span class="comment">//去除孩子</span></span><br><span class="line">        <span class="keyword">int</span> cnt = nodes[oldCmd.newDir].allNodes;</span><br><span class="line">        pushForward(oldCmd.pwd,<span class="number">-1</span>*cnt);<span class="comment">//更新allnNodes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oldCmd.command == <span class="string">"rm"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        nodes[oldCmd.pwd].children[nodes[oldCmd.newDir].nodeName] = oldCmd.newDir;<span class="comment">//加回孩子</span></span><br><span class="line">        <span class="keyword">int</span> cnt = nodes[oldCmd.newDir].allNodes;</span><br><span class="line">        pushForward(oldCmd.pwd,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(oldCmd.command == <span class="string">"cd"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        curPosi = oldCmd.pwd;<span class="comment">//直接回退</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"OK\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstRoot</span><span class="params">(<span class="keyword">int</span> ptr,<span class="keyword">int</span> cur)</span><span class="comment">//在allNodes小于10的时候直接先根遍历更新ftree就行了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nodes[ptr].ftree.push_back(nodes[cur].nodeName);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:nodes[cur].children)</span><br><span class="line">        firstRoot(ptr,i.second);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_end</span><span class="params">(<span class="keyword">int</span> ptr)</span><span class="comment">//更新ftree</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nodes[ptr].change == <span class="number">0</span>)<span class="comment">//已经更新过了</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(nodes[ptr].allNodes&lt;=<span class="number">10</span>)<span class="comment">//10个节点及一下</span></span><br><span class="line">    &#123;</span><br><span class="line">        firstRoot(ptr,ptr);</span><br><span class="line">        nodes[ptr].change = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nodes[ptr].children)<span class="comment">//更新所有孩子的</span></span><br><span class="line">            begin_end(i.second);</span><br><span class="line">        nodes[ptr].ftree.push_back(nodes[ptr].nodeName);<span class="comment">//先放入自己</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nodes[ptr].children)<span class="comment">//前4个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=<span class="number">4</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;nodes[i.second].ftree.size();t++)</span><br><span class="line">                <span class="keyword">if</span>(cnt++&lt;<span class="number">4</span>)</span><br><span class="line">                    nodes[ptr].ftree.push_back(nodes[i.second].ftree[t]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::reverse_iterator it=nodes[ptr].children.rbegin();it!=nodes[ptr].children.rend();it++)<span class="comment">//后5个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=<span class="number">5</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=nodes[(*it).second].ftree.size()<span class="number">-1</span>;t&gt;=<span class="number">0</span>;t--)<span class="comment">//倒着的</span></span><br><span class="line">                <span class="keyword">if</span>(cnt++&lt;<span class="number">5</span>)</span><br><span class="line">                    nodes[ptr].ftree.insert(nodes[ptr].ftree.begin()+<span class="number">5</span>,nodes[(*it).second].ftree[t]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes[ptr].change = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tree</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childSize = nodes[curPosi].allNodes;</span><br><span class="line">    <span class="keyword">if</span>( childSize== <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"EMPTY\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125; </span><br><span class="line">    begin_end(curPosi);</span><br><span class="line">    <span class="keyword">if</span>(childSize&lt;=<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:nodes[curPosi].ftree)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;nodes[curPosi].ftree[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"...\n"</span>;<span class="comment">//输出... 仔细看提</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;nodes[curPosi].ftree[i]&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">treeNode <span class="title">rootNode</span> <span class="params">(<span class="string">"root"</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> curCmd;</span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        nodes.clear();<span class="comment">//空间释放!!!!</span></span><br><span class="line">        nodes.push_back(rootNode);</span><br><span class="line">        <span class="keyword">while</span>(!history.empty())</span><br><span class="line">            history.pop();</span><br><span class="line">        curPosi = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;q;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;curCmd;</span><br><span class="line">            <span class="keyword">if</span>(curCmd == <span class="string">"MKDIR"</span>) mkdir();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curCmd == <span class="string">"RM"</span>) rm();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curCmd == <span class="string">"CD"</span>) cd();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curCmd == <span class="string">"SZ"</span>) sz();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curCmd == <span class="string">"LS"</span>) ls();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curCmd == <span class="string">"TREE"</span>) tree();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(curCmd == <span class="string">"UNDO"</span>) undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>把本次模拟较为复杂,难点主要集中在tree的实现上,因为数据规模的原因直接进行前序遍历复杂度会超时,因此采取记忆化的操作,这样只在插入删除新的节点后才进行更新,其他情况直接使用存储的tree信息.</p>
<p>除此之外stl的map使用也值得一看,直接实现了有序的查找,复杂度还低</p>
<h2 id="B-东东学打牌"><a href="#B-东东学打牌" class="headerlink" title="B - 东东学打牌"></a><a href="https://vjudge.net/problem/计蒜客-41408" target="_blank" rel="noopener">B - 东东学打牌</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>和之前做过的那个发牌的题挺类似,使用类似搜索的方法</p>
<p><img src="https://i.loli.net/2020/05/04/mj8enzuLZFfSGKM.png" alt="image-20200504185524882"></p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>首先使用个结构体来handCard记录一个人的姓名和手牌,姓名使用string手牌使用vector,手牌转换为数字.使用一个handCard数组记录有所人的手牌.</p>
<p>然后开8个vector,分别表示8种情况下的人,然后写8个函数,分别判断一个人的手牌是哪一种情况,然后分配到对应的vector</p>
<p>针对这个8种情况编写几个排序函数,实现题目中要求的顺序,有几个排序方法使能复用的.</p>
<p>在8个判断函数中,使用map实现对同一数字手牌个数的判断.</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;<span class="comment">//手牌和人名</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handCard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cards;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handCard allCard[<span class="number">1000</span>];<span class="comment">//所有人的情况</span></span><br><span class="line"><span class="keyword">int</span> exchanges[<span class="number">100</span>];<span class="comment">//将ascii码转换为对应的数字</span></span><br><span class="line"><span class="keyword">int</span> longshun[] = &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;<span class="comment">//龙顺判断</span></span><br><span class="line"><span class="comment">// priority_queue&lt;string,vector&lt;string&gt;,greater&lt;string&gt; &gt; ans[8];</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans[<span class="number">8</span>];<span class="comment">//8种类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getCardNum</span><span class="params">(<span class="keyword">int</span> ptr,<span class="keyword">int</span> i)</span><span class="comment">//获取一张手牌</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> allCard[ptr].cards[i];&#125;</span><br><span class="line"></span><br><span class="line">map&lt;int,int&gt; getCnt(int ptr)//获得计数的字典</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        mp[allCard[ptr].cards[i]]++;</span><br><span class="line">    <span class="keyword">return</span> mp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">distribute</span><span class="params">(<span class="keyword">int</span> ptr)</span><span class="comment">//判断一套牌属于哪一个类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp = getCnt(ptr);</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span> ;</span><br><span class="line">    &#123;<span class="comment">//龙顺</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(allCard[ptr].cards[i]!=longshun[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">7</span>].push_back(ptr);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//顺子</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(allCard[ptr].cards[i]+<span class="number">1</span>!=allCard[ptr].cards[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">6</span>].push_back(ptr);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//炸弹</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line">            <span class="keyword">if</span>(t.second == <span class="number">4</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[<span class="number">5</span>].push_back(ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//三带二</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line">            <span class="keyword">if</span>(t.second!=<span class="number">3</span>&amp;&amp;t.second!=<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">4</span>].push_back(ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//三个</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line">            <span class="keyword">if</span>(t.second == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[<span class="number">3</span>].push_back(ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//两对</span></span><br><span class="line">        <span class="keyword">int</span> flag =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line">            <span class="keyword">if</span>(t.second == <span class="number">2</span>)</span><br><span class="line">                flag++;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[<span class="number">2</span>].push_back(ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;<span class="comment">//对子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:mp)</span><br><span class="line">            <span class="keyword">if</span>(t.second == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans[<span class="number">1</span>].push_back(ptr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">0</span>].push_back(ptr);<span class="comment">//大牌</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nameOrder</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//比较大牌,实际上就是名字的字典序</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> allCard[a].name&gt;allCard[b].name;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">numOrder</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//所有手牌和的大小,顺子比较直接使用,大数也直接使用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> al=<span class="number">0</span>,bl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">        al+=allCard[a].cards[i],bl+=allCard[b].cards[i];</span><br><span class="line">    <span class="keyword">if</span>(al&lt;bl)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (al==bl)</span><br><span class="line">        <span class="keyword">return</span> nameOrder(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp6</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//炸弹</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(getCardNum(a,<span class="number">1</span>)&lt;getCardNum(b,<span class="number">1</span>))<span class="comment">//炸弹大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(getCardNum(a,<span class="number">1</span>) == getCardNum(b,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> numOrder(a,b);<span class="comment">//比较剩下的一张牌</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp5</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//三带二</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mpa = getCnt(a);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mpb = getCnt(b);</span><br><span class="line">    <span class="keyword">int</span> al=<span class="number">0</span>,bl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:mpa)</span><br><span class="line">        <span class="keyword">if</span>(t.second == <span class="number">3</span>) al=t.first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:mpb)</span><br><span class="line">        <span class="keyword">if</span>(t.second == <span class="number">3</span>) bl=t.first;</span><br><span class="line">    <span class="keyword">if</span>(al&lt;bl)<span class="comment">//比较三</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(al==bl)<span class="comment">//比较二</span></span><br><span class="line">        <span class="keyword">return</span> numOrder(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三个和三带二一样</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//两对</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> al[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> bl[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mpa = getCnt(a);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mpb = getCnt(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:mpa)</span><br><span class="line">        <span class="keyword">if</span>(t.second == <span class="number">2</span>)<span class="comment">//两个对子</span></span><br><span class="line">            al[i++] = t.first;</span><br><span class="line">    i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:mpb)</span><br><span class="line">        <span class="keyword">if</span>(t.second == <span class="number">2</span>)</span><br><span class="line">            bl[i++] = t.first;</span><br><span class="line">    <span class="keyword">if</span>(al[<span class="number">1</span>]&lt;bl[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(al[<span class="number">1</span>]==bl[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span>(al[<span class="number">0</span>]&lt;bl[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(al[<span class="number">0</span>] == bl[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> numOrder(a,b);<span class="comment">//比较剩下的那一个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//对子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mpa = getCnt(a);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mpb= getCnt(b);</span><br><span class="line">    <span class="keyword">int</span> al=<span class="number">0</span>,bl=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:mpa)</span><br><span class="line">        <span class="keyword">if</span>(t.second == <span class="number">2</span>)   al =t.first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:mpb)</span><br><span class="line">        <span class="keyword">if</span>(t.second == <span class="number">2</span>)   bl=t.first;</span><br><span class="line">    <span class="keyword">if</span>(al&lt;bl) <span class="comment">//比较唯一的一个对子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(al == bl)</span><br><span class="line">        <span class="keyword">return</span> numOrder(a,b);<span class="comment">//比较剩下的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(ans[<span class="number">0</span>].begin(),ans[<span class="number">0</span>].end(),numOrder);<span class="comment">//排序</span></span><br><span class="line">    sort(ans[<span class="number">1</span>].begin(),ans[<span class="number">1</span>].end(),cmp2);</span><br><span class="line">    sort(ans[<span class="number">2</span>].begin(),ans[<span class="number">2</span>].end(),cmp3);</span><br><span class="line">    sort(ans[<span class="number">3</span>].begin(),ans[<span class="number">3</span>].end(),cmp5);</span><br><span class="line">    sort(ans[<span class="number">4</span>].begin(),ans[<span class="number">4</span>].end(),cmp5);</span><br><span class="line">    sort(ans[<span class="number">5</span>].begin(),ans[<span class="number">5</span>].end(),cmp6);</span><br><span class="line">    sort(ans[<span class="number">6</span>].begin(),ans[<span class="number">6</span>].end(),numOrder);</span><br><span class="line">    sort(ans[<span class="number">7</span>].begin(),ans[<span class="number">7</span>].end(),nameOrder);</span><br><span class="line">    <span class="comment">// sort(ans[0].begin(),ans[0].end(),);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">7</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it=ans[i].rbegin();it!=ans[i].rend();it++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;allCard[*it].name&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span><span class="comment">//读入一个ascii转换为int</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;temp);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="string">'1'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> change[temp];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(change,<span class="number">0</span>,<span class="keyword">sizeof</span>(change));</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i=<span class="string">'2'</span>;i&lt;=<span class="string">'9'</span>;i++,s++)</span><br><span class="line">        change[i] = s;</span><br><span class="line">    change[<span class="string">'A'</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line">    change[<span class="string">'J'</span>] = <span class="number">11</span>;</span><br><span class="line">    change[<span class="string">'Q'</span>] = <span class="number">12</span>;</span><br><span class="line">    change[<span class="string">'K'</span>] = <span class="number">13</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// getchar();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            allCard[i].cards.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">            ans[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;allCard[i].name;</span><br><span class="line">            getchar();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;<span class="number">5</span>;t++)</span><br><span class="line">                allCard[i].cards.push_back(readInt());</span><br><span class="line">            sort(allCard[i].cards.begin(),allCard[i].cards.end());<span class="comment">//将每张手牌排序</span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">            distribute(i);<span class="comment">//把每个人手牌的类型分类</span></span><br><span class="line">        output();<span class="comment">//输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题不是很难,主要是就是考虑题目中给出的几个情况的判断,判断同一个大小的牌数是一个比较麻烦的部分,使用map复杂度能低一些.另一个重要的地方是函数结构的设计,尽量提高的代码的复用率</p>
<h2 id="C-签到题，独立思考哈"><a href="#C-签到题，独立思考哈" class="headerlink" title="C - 签到题，独立思考哈"></a><a href="https://vjudge.net/problem/CodeForces-1042A" target="_blank" rel="noopener">C - 签到题，独立思考哈</a></h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/04/MhjWDYoq5uE6TXR.png" alt=""></p>
<p>这个题实际上就是一个分配的问题,如何分配使所有单位的最大值最大或者最小</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>首先最大值最小首先采取的方法就是平均值,一平均就是最小的,但是因为已经分配好的不能再懂了,如果现在的最大值比平均后的值大,说明加入y之后最小的最大值还是原来的最大值,如果最大值小于平均值,那么平均值就是最小最大值</p>
<p>最大最大值就很简单了,直接在现在最大值的基础上加上y就行了</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,data+i);</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;<span class="comment">//当前的总计,用于求平均数</span></span><br><span class="line">    <span class="keyword">int</span> Max=<span class="number">0</span>;<span class="comment">//当前的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;x;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=data[i];<span class="comment">//统计</span></span><br><span class="line">        <span class="keyword">if</span>(data[i]&gt;Max) Max = data[i];<span class="comment">//最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mn = <span class="built_in">ceil</span>((sum+y)/(x*<span class="number">1.0</span>));<span class="comment">//加上y的平均数</span></span><br><span class="line">    <span class="keyword">if</span>(mn&lt;Max)<span class="comment">//当前最大值大于平均数</span></span><br><span class="line">        mn = Max;<span class="comment">//取当前最大值</span></span><br><span class="line">    <span class="keyword">int</span> mx = Max+y;<span class="comment">///最大的最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,mn,mx); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这道题不难,主要是就把最小的最大值情况想全了就行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/29/Program-week10-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/29/Program-week10-homework/" itemprop="url">Program-week10-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-29T21:28:09+08:00">
                2020-04-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week10-homework"><a href="#week10-homework" class="headerlink" title="week10-homework"></a>week10-homework</h1><h2 id="A-签到题"><a href="#A-签到题" class="headerlink" title="A - 签到题"></a><a href="https://vjudge.net/problem/CodeForces-1141A" target="_blank" rel="noopener">A - 签到题</a></h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/13/oWrKmnd8pHkwOzN.png" alt=""></p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>直接m/n看看是不能整除,不整除,直接输出-1</p>
<p>整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(m%n!=<span class="number">0</span>||n&gt;m)<span class="comment">//能整除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = m/n;<span class="comment">//倍数</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t%<span class="number">2</span> == <span class="number">0</span>)<span class="comment">//一直/2直到不能进行</span></span><br><span class="line">    &#123;</span><br><span class="line">        t/=<span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t%<span class="number">3</span> == <span class="number">0</span>)<span class="comment">//一直除3直到不能进行</span></span><br><span class="line">    &#123;</span><br><span class="line">        t/=<span class="number">3</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t!=<span class="number">1</span>)<span class="comment">//除不尽</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//除尽</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>问题不难,考虑除尽的情况即可</p>
<h2 id="B-LIS-amp-LCS"><a href="#B-LIS-amp-LCS" class="headerlink" title="B - LIS &amp; LCS"></a><a href="https://vjudge.net/problem/Gym-277140A" target="_blank" rel="noopener">B - LIS &amp; LCS</a></h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/13/ImC1iALlYHBNZXf.png" alt="image-20200513115536949"></p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>这是一道DP的模板题</p>
<p>对于LIS 最长上升子序列而言,使用1维dp即可</p>
<p>$dp[j] = max(dp[i],\ (data[i]&lt;data[j],\ i&lt;j))+1$</p>
<p>$dp[j]$表示序列中第j个位置,以data[j]结尾的字符的LIS,全局的最大值要从整个序列中取最大值</p>
<p>对于LRS最长公共子序列,需要使用二维的DP,因为涉及到对两个区间的操作</p>
<p>$dp[i][j]$表示第一个序列第i个位置和第二个序列第j个位置的最长公共子序列长度</p>
<p>状态转移方程如下:</p>
<p>$A[i] == B[j]\ \ \ \ dp[i][j] = dp[i-1][j-1]+1$<br>$A[i]!=B[j]\ \ \ \ dp[i][j]=max(dp[i-1][j],dp[i][j-1])$</p>
<p>初始化所有长度为0</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//最长上升子序列和最长公共子序列</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">5005</span>];<span class="comment">//两个序列原始信息</span></span><br><span class="line"><span class="keyword">int</span> B[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> LIS[<span class="number">5005</span>];<span class="comment">//存储答案</span></span><br><span class="line"><span class="keyword">int</span> LRS[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findLIS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> allMax = <span class="number">0</span>;<span class="comment">//最长上升子序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = A[i];</span><br><span class="line">        <span class="keyword">int</span> Max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;i;t++)</span><br><span class="line">            <span class="keyword">if</span>(A[t]&lt;temp)</span><br><span class="line">                <span class="keyword">if</span>(LIS[t]&gt;Max)<span class="comment">//状态转移方程</span></span><br><span class="line">                    Max = LIS[t];<span class="comment">//取比A[i]小的元素的最大值</span></span><br><span class="line">        LIS[i] = Max+<span class="number">1</span>;<span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">if</span>(Max+<span class="number">1</span>&gt;allMax)</span><br><span class="line">            allMax = Max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> allMax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findLRS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=m;t++)</span><br><span class="line">            <span class="keyword">if</span>(A[i<span class="number">-1</span>] == B[t<span class="number">-1</span>])</span><br><span class="line">                LRS[i][t] = LRS[i<span class="number">-1</span>][t<span class="number">-1</span>]+<span class="number">1</span>;<span class="comment">//相同更新加1</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                LRS[i][t] = max(LRS[i<span class="number">-1</span>][t],LRS[i][t<span class="number">-1</span>]);<span class="comment">//矩阵上方或则左侧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(LIS,<span class="number">0</span>,<span class="keyword">sizeof</span>(LIS));</span><br><span class="line">    <span class="built_in">memset</span>(LRS,<span class="number">0</span>,<span class="keyword">sizeof</span>(LRS));</span><br><span class="line">    <span class="built_in">memset</span>(A,<span class="number">0</span>,<span class="keyword">sizeof</span>(A));</span><br><span class="line">    <span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(B));<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,A+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,B+i);</span><br><span class="line">    <span class="keyword">int</span> maxELe = findLIS();</span><br><span class="line">    findLRS();</span><br><span class="line">    <span class="keyword">int</span> ans2 = LRS[n][m];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,maxELe,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>dp 四件套 状态表示 转移方程 初始条件 转移策略</p>
<p>转移状态非常重要,LIS的状态表示没有直接给出要求的东西,但是能通过其他方法求取这个最大值,挺妙,得多想想</p>
<h2 id="C-拿数问题-II"><a href="#C-拿数问题-II" class="headerlink" title="C - 拿数问题 II"></a><a href="https://vjudge.net/problem/CodeForces-455A" target="_blank" rel="noopener">C - 拿数问题 II</a></h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/13/LAEqapWsrVHfM5w.png" alt=""></p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这道题是对课上题目的小改,其实就是对一开始输入的系列进行一些处理,首先排个序,然后将所有相同的值合并,构造两个新序列,$pdata[i]$表示新序列对应位置的原始值,$process[i]$是原序列中$pdata[i]$的值的和(就是相当于把相同的值都加起来,然后保留加和和原本的值).</p>
<p>然后开始dp,$dp[i]$表示到第i个位置,总和最大值是多少​.</p>
<p>$pdata[i]==pdata[i-1]+1\ \ \ \ dp[i]=max(process[i]+dp[i-2],dp[i-1])$</p>
<p>$pdata[i]!=pdata[i-1]+1\ \ \ \ dp[i]=process[i]+dp[i-1]$</p>
<p>初始化为0,然后从小到大开始dp即可</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> data[<span class="number">100005</span>];<span class="comment">//原始数据</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> process[<span class="number">100005</span>];<span class="comment">//合并所有相同项后</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans[<span class="number">100005</span>];<span class="comment">//结果</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> pdata[<span class="number">100005</span>];<span class="comment">//process对应位置的原先的值</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(process,<span class="number">0</span>,<span class="keyword">sizeof</span>(process));</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">memset</span>(pdata,<span class="number">0</span>,<span class="keyword">sizeof</span>(pdata));<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,data+i);</span><br><span class="line">    sort(data,data+n);<span class="comment">//排序</span></span><br><span class="line">    m=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> temp = data[i];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = data[i];</span><br><span class="line">        <span class="keyword">while</span>(temp == data[i+<span class="number">1</span>])</span><br><span class="line">            sum+=data[++i];</span><br><span class="line">        pdata[m]=temp;<span class="comment">//原先的值</span></span><br><span class="line">        process[m++] = sum;<span class="comment">//计算和</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans[<span class="number">0</span>] = process[<span class="number">0</span>];<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(pdata[<span class="number">1</span>] == pdata[<span class="number">0</span>]+<span class="number">1</span>)</span><br><span class="line">        ans[<span class="number">1</span>] = max(ans[<span class="number">0</span>],process[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans[<span class="number">1</span>] = ans[<span class="number">0</span>]+process[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pdata[i] == pdata[i<span class="number">-1</span>]+<span class="number">1</span>)<span class="comment">//不能取前一个数</span></span><br><span class="line">            ans[i]= max(ans[i<span class="number">-1</span>],process[i]+ans[i<span class="number">-2</span>]);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//能取前一个数,直接加</span></span><br><span class="line">            ans[i] = ans[i<span class="number">-1</span>]+process[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans[m<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这道题数据范围需要稍微注意一下,可能会超int,dp的规则相较于课上讲的其实变化不大,只不过需要多一步预处理.</p>
<h1 id="CSP-模拟"><a href="#CSP-模拟" class="headerlink" title="CSP-模拟"></a>CSP-模拟</h1><h2 id="A-签到题-1"><a href="#A-签到题-1" class="headerlink" title="A - 签到题"></a><a href="https://vjudge.net/problem/AtCoder-2041" target="_blank" rel="noopener">A - 签到题</a></h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/13/LuBieR152XMxVjz.png" alt=""></p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这道题就是非常简单的判断最大最小值问题</p>
<p>题目让切分图形,最简单的就是长宽高方向切分,那么一共有三种面,求出最小的那个面就可以了</p>
<p>数据给到了1e9,用int会爆,因此用long long</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//数据范围用long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(a%<span class="number">2</span>==<span class="number">0</span>||b%<span class="number">2</span>==<span class="number">0</span>||c%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找三个面最小的那一个</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> Min = b*c;</span><br><span class="line">    <span class="keyword">if</span>(Min&gt;a*b)</span><br><span class="line">        Min = a*b;</span><br><span class="line">    <span class="keyword">if</span>(Min&gt;a*c)</span><br><span class="line">        Min = a*c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,Min);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>难度不大,还是要关注一下数据范围,会超int</p>
<h2 id="B-团-队-聚-会"><a href="#B-团-队-聚-会" class="headerlink" title="B - 团 队 聚 会"></a><a href="https://vjudge.net/problem/POJ-1960" target="_blank" rel="noopener">B - 团 队 聚 会</a></h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><p><img src="https://i.loli.net/2020/05/13/tWUm59dogr6XBsP.png" alt="image-20200513142515530"></p>
<p>题面稍微有点长,大致意思就是又一系列区间,要求求出没有不区间覆盖为部分(或者仅被一个区间覆盖)</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>题目本身很简单,但是因为区间的格式有点复杂,是一个确切的时间,因此要针对时间进行处理<br>首先写一个时间结构体,这个结构体有6个变量,分别是年月日时分秒,用来对应输入的时间,然后写好比较函数</p>
<p>然后写一个事件结构体event,包含两个时间点,一个起始时间,一个结束时间,然后两个时间点表示一段时间,这一段时间表示一个时间,用来存储输出的事件</p>
<p>我们使用两个堆,一个堆allTime存储所有的时间点,就是每个人每个时间段的开始时间和结束时间,另一个是堆数组person,用来存储每个人的事件,堆中排序依据事件起始事件,用一个vector存储所有的空闲时间段</p>
<p>编写事件处理函数,将每个人每个事件都存储为event,加入到对应的堆中,同时把每个时间也加入到allTime,</p>
<p>然后从allTime中提出两个时间,组成一个event,检查这个event所有人是否有空,如果满足条件,满足条件就将这个event加入到vector中,一直重复到堆空</p>
<p>检查过程就是先看看每个人堆顶的起始时间和待检测的结束时间关系,如果大于,则有空,如果小于,且待检测的开始时间晚于堆顶开始时间,待检测时间结束时间早于堆顶结束时间,则说明有事,如果堆顶结束时间早于待检测开始时间,弹出堆顶,继续检测</p>
<p>最终所有有空的时间都到了vector中,我们要输出这个时间,这其中有连续的时间被分割成多个连续片段的情况,因此要先合并,然后检查合并后的时间长度是否大于1h,是就输出.</p>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dataInfo[<span class="number">6</span>];<span class="comment">//时间从年到秒</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> time&amp; op) <span class="keyword">const</span> <span class="comment">//重载操作符 一定要是const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dataInfo[i]&lt;op.dataInfo[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dataInfo[i] == op.dataInfo[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;            </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> time&amp;  op)<span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dataInfo[i]!=op.dataInfo[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt;(<span class="keyword">const</span> time&amp; op)<span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dataInfo[i]&gt;op.dataInfo[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dataInfo[i] == op.dataInfo[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;=(<span class="keyword">const</span> time&amp; op)<span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dataInfo[i]&lt;op.dataInfo[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dataInfo[i] == op.dataInfo[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">            <span class="keyword">if</span>(dataInfo[i]!=op.dataInfo[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//起始写麻烦了,可以写一个然后调用</span></span><br><span class="line">    time()&#123;&#125;;</span><br><span class="line">    time(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day,<span class="keyword">int</span> hour,<span class="keyword">int</span> minute,<span class="keyword">int</span> second)</span><br><span class="line">    &#123;</span><br><span class="line">        dataInfo[<span class="number">0</span>] = year;</span><br><span class="line">        dataInfo[<span class="number">1</span>] = month;</span><br><span class="line">        dataInfo[<span class="number">2</span>] = day;</span><br><span class="line">        dataInfo[<span class="number">3</span>] = hour;</span><br><span class="line">        dataInfo[<span class="number">4</span>] = minute;</span><br><span class="line">        dataInfo[<span class="number">5</span>] = second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> </span></span><br><span class="line"><span class="class">&#123;</span> <span class="comment">//一个时间,包括起始时间和结束时间</span></span><br><span class="line">    time startTime;</span><br><span class="line">    time endTime;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> event&amp; op) <span class="keyword">const</span> </span><br><span class="line">    &#123; <span class="keyword">return</span> startTime &gt; op.startTime;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//最小堆</span></span><br><span class="line">priority_queue&lt;time,<span class="built_in">vector</span>&lt;time&gt;,greater&lt;time&gt; &gt; allTime;<span class="comment">//所有时间点的数组</span></span><br><span class="line">priority_queue&lt;event,<span class="built_in">vector</span>&lt;event&gt;,greater&lt;event&gt; &gt; person[<span class="number">22</span>];<span class="comment">//每个人的事件</span></span><br><span class="line"><span class="built_in">vector</span>&lt;event&gt; freeTime;<span class="comment">//存储一小段一小段能开会的时间</span></span><br><span class="line"><span class="keyword">int</span> perCnt;<span class="comment">//人数</span></span><br><span class="line"></span><br><span class="line"><span class="function">event <span class="title">readTime</span><span class="params">()</span><span class="comment">//读入一个时间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    event tempEvent;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,tempEvent.startTime.dataInfo+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,tempEvent.endTime.dataInfo+i);</span><br><span class="line">    <span class="keyword">while</span>(getchar()!=<span class="string">'\n'</span>)<span class="comment">//去除后面没用的文字</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> tempEvent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkFree</span><span class="params">(<span class="keyword">int</span> ptr,<span class="keyword">const</span> event&amp; curTime)</span><span class="comment">//检查一个人在一个时间段是不是有空的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(person[ptr].empty())<span class="comment">//什么事都没了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    event curEvent = person[ptr].top();<span class="comment">//最靠前的事</span></span><br><span class="line">    <span class="keyword">if</span>(curTime.endTime &lt;= curEvent.startTime)<span class="comment">//当前没有事</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(curEvent.startTime&lt;=curTime.startTime&amp;&amp;curTime.endTime&lt;=curEvent.endTime)<span class="comment">//当前有事</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(curEvent.endTime&lt;=curTime.startTime)<span class="comment">//当前的事已经干完了,取下一个事</span></span><br><span class="line">    &#123;</span><br><span class="line">        person[ptr].pop();</span><br><span class="line">        <span class="keyword">return</span> checkFree(ptr,curTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkAllPerson</span><span class="params">()</span><span class="comment">//检查所有人的时间情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    event curEvent;<span class="comment">//当前时间段</span></span><br><span class="line">    <span class="keyword">while</span>(!allTime.empty())<span class="comment">//时间点不空</span></span><br><span class="line">    &#123;</span><br><span class="line">        curEvent.startTime = allTime.top();</span><br><span class="line">        allTime.pop();</span><br><span class="line">        <span class="keyword">if</span>(allTime.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        curEvent.endTime = allTime.top();<span class="comment">//取两个时间点组成一个时间片段,检查时间片段内是否能开会</span></span><br><span class="line">        <span class="keyword">if</span>(curEvent.startTime == curEvent.endTime)<span class="comment">//无效时间片段</span></span><br><span class="line">        	<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;perCnt;i++)</span><br><span class="line">            cnt+=checkFree(i,curEvent);<span class="comment">//有空人的个数</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=perCnt<span class="number">-1</span>&amp;&amp;cnt&gt;=<span class="number">2</span>)<span class="comment">//能开会</span></span><br><span class="line">            freeTime.push_back(curEvent);<span class="comment">//将开会时间片段放入freeTime</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMin</span><span class="params">(<span class="keyword">const</span> time&amp; t,<span class="keyword">int</span> i)</span><span class="comment">//输出时间的每一个小段</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t.dataInfo[i]&gt;=<span class="number">10</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,t.dataInfo[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.dataInfo[i]&lt;<span class="number">10</span>&amp;&amp;t.dataInfo[i]&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0%d"</span>,t.dataInfo[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(t.dataInfo[i] == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"00"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTime</span><span class="params">(<span class="keyword">const</span> time&amp; s)</span><span class="comment">//输出时间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printMin(s,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"/"</span>);</span><br><span class="line">    printMin(s,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"/"</span>);</span><br><span class="line">    printMin(s,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    printMin(s,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">":"</span>);</span><br><span class="line">    printMin(s,<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">":"</span>);</span><br><span class="line">    printMin(s,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkLimit</span><span class="params">(time s,time e)</span><span class="comment">//检查时间段下限,时间要超过1h</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    time newTime ;</span><br><span class="line">    <span class="keyword">int</span> t= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.dataInfo[<span class="number">3</span>]+<span class="number">1</span>&gt;=<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newTime.dataInfo[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.dataInfo[<span class="number">2</span>]+<span class="number">1</span>&gt;=<span class="number">31</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            newTime.dataInfo[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.dataInfo[<span class="number">1</span>]+<span class="number">1</span>&gt;=<span class="number">13</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newTime.dataInfo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                newTime.dataInfo[<span class="number">0</span>] = s.dataInfo[<span class="number">0</span>]+<span class="number">1</span>;</span><br><span class="line">                t = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">            	newTime.dataInfo[<span class="number">1</span>] = s.dataInfo[<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            	t=<span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        	newTime.dataInfo[<span class="number">2</span>] = s.dataInfo[<span class="number">2</span>]+<span class="number">1</span>;</span><br><span class="line">        	t=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    	newTime.dataInfo[<span class="number">3</span>] = s.dataInfo[<span class="number">3</span>]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=t;i++)</span><br><span class="line">        newTime.dataInfo[i] = s.dataInfo[i];</span><br><span class="line">    newTime.dataInfo[<span class="number">4</span>]= s.dataInfo[<span class="number">4</span>];</span><br><span class="line">    newTime.dataInfo[<span class="number">5</span>] = s.dataInfo[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">return</span> newTime&lt;=e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    event startEvent;</span><br><span class="line">    event endEvent;</span><br><span class="line">    time st;</span><br><span class="line">    time et;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;<span class="comment">//没有可用时间标置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;freeTime.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        st = freeTime[i].startTime;</span><br><span class="line">        et = freeTime[i].endTime;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;freeTime.size()<span class="number">-1</span>)<span class="comment">//多个时间段可能是连着的,需要合成一个</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(et == freeTime[i+<span class="number">1</span>].startTime)<span class="comment">//头尾相连</span></span><br><span class="line">                et=freeTime[++i].endTime;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!checkLimit(st,et))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        flag = <span class="number">0</span>;<span class="comment">//有可用时间</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"appointment possible from "</span>);</span><br><span class="line">        printTime(st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" to "</span>);</span><br><span class="line">        printTime(et);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"no appointment possible\n"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)<span class="comment">//输出格式</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;perCnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;perCnt;c++)</span><br><span class="line">            <span class="keyword">while</span>(!person[c].empty()) </span><br><span class="line">            	person[c].pop();</span><br><span class="line">        <span class="keyword">while</span>(!allTime.empty())</span><br><span class="line">            allTime.pop();</span><br><span class="line">        freeTime.clear();<span class="comment">//清空</span></span><br><span class="line">        <span class="keyword">int</span> endCheck = <span class="number">1</span>;</span><br><span class="line">        <span class="function">time <span class="title">rbegin</span><span class="params">(<span class="number">1800</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//总的开始时间</span></span><br><span class="line">        <span class="function">time <span class="title">rend</span><span class="params">(<span class="number">2200</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;<span class="comment">//总的结束时间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;perCnt;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;n;m++)</span><br><span class="line">            &#123;</span><br><span class="line">                event tempEve = readTime();</span><br><span class="line">                person[j].push(tempEve);<span class="comment">//每个人的事件</span></span><br><span class="line">                <span class="keyword">if</span>(tempEve.endTime == rend)</span><br><span class="line">                    endCheck = <span class="number">0</span>;</span><br><span class="line">                allTime.push(tempEve.startTime);<span class="comment">//每一个时间点</span></span><br><span class="line">                allTime.push(tempEve.endTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!(allTime.top()==rbegin))<span class="comment">//重复插入,其实不用管</span></span><br><span class="line">            allTime.push(rbegin);</span><br><span class="line">        <span class="keyword">if</span>(endCheck)</span><br><span class="line">            allTime.push(rend);</span><br><span class="line">        checkAllPerson();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>,i+<span class="number">1</span>);</span><br><span class="line">        output();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这道题思路不麻烦,难的是代码的编写,这次写的非常丑,时间比较那里可以简化一下,同时可以把时间直接转换为秒,代码量更少.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/15/Program-week8-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/15/Program-week8-homework/" itemprop="url">Program-week8-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-15T09:09:31+08:00">
                2020-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="homework"><a href="#homework" class="headerlink" title="homework"></a>homework</h1><h2 id="A-区间选点-II"><a href="#A-区间选点-II" class="headerlink" title="A - 区间选点 II"></a>A - 区间选点 II</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><p><img src="https://i.loli.net/2020/04/15/ZlMCLTWAFiN5dKj.png" alt=""></p>
<p>题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>本道题要求使用差分约束来解</p>
<p>差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).</p>
<p>下面开始构建约束</p>
<p>对于给出的区间(i,j)要求k的点我们可以构建方程</p>
<p>$dis[j]-dis[i-1]\geq k$</p>
<p>除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束</p>
<p>$0\leq dis[t]-dis[t-1]\leq 1$s</p>
<p>题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$</p>
<p>综上我们知道了如下信息</p>
<script type="math/tex; mode=display">
dis[min-1] =0\\
dis[j]-dis[i]\geq k\\
dis[t]-dis[t-1]\geq 0\\
dis[t-1] - dis[t]\geq -1</script><p>我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断</p>
<p>求出最长路只需要换一下啊松弛条件就可以了</p>
<p>这道题复杂度同SPFA一样,O(KM)</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; G[<span class="number">50005</span>];<span class="comment">//图</span></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//队列</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">50005</span>];<span class="comment">//最大值,差分数组</span></span><br><span class="line"><span class="keyword">int</span> inque[<span class="number">50005</span>];<span class="comment">//是否在队列中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">-128</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(inque,<span class="number">0</span>,<span class="keyword">sizeof</span>(inque));</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">50005</span>,max = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        a+=<span class="number">1</span>,b+=<span class="number">1</span>;<span class="comment">//把从0开始改为从1开始</span></span><br><span class="line">        <span class="keyword">if</span>(a&lt;min)</span><br><span class="line">            min = a;<span class="comment">//起始位置</span></span><br><span class="line">        <span class="keyword">if</span>(b&gt;max)</span><br><span class="line">            max = b;<span class="comment">//结束位置</span></span><br><span class="line">        G[a<span class="number">-1</span>].push_back(make_pair(b,c));<span class="comment">//有向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=min<span class="number">-1</span>;i&lt;max;i++)</span><br><span class="line">        G[i].push_back(make_pair(i+<span class="number">1</span>,<span class="number">0</span>));<span class="comment">//两点之差大于0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=min<span class="number">-1</span>;i&lt;max;i++)</span><br><span class="line">        G[i+<span class="number">1</span>].push_back(make_pair(i,<span class="number">-1</span>));<span class="comment">//两点之差小于1</span></span><br><span class="line">    <span class="comment">// dis[a]=0;</span></span><br><span class="line">    q.push(min<span class="number">-1</span>);<span class="comment">//从整个点开始遍历dis[min-1]</span></span><br><span class="line">    dis[min<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inque[temp] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;:: iterator i =G[temp].begin();i!=G[temp].end();i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dis[(*i).first]&lt;dis[temp]+(*i).second)<span class="comment">//最长路</span></span><br><span class="line">            &#123;</span><br><span class="line">                dis[(*i).first] = dis[temp]+(*i).second;<span class="comment">//更新最长</span></span><br><span class="line">                <span class="keyword">if</span>(inque[(*i).first] == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                q.push((*i).first);</span><br><span class="line">                inque[(*i).first] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[max]);<span class="comment">//输出最终位置的值就是全局消耗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题是一道简单的差分约束题目,差分约束的难点主要在寻找到约束变量,同时构建出约束关系,这个约束条件一般有两部分一部分是题目直接给出的,另一部分是为了使题目有意义,隐含构建的,最后还要确认一个起点,其他点都是以这个为基础.</p>
<h2 id="B-猫猫向前冲"><a href="#B-猫猫向前冲" class="headerlink" title="B - 猫猫向前冲"></a>B - 猫猫向前冲</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p><img src="https://i.loli.net/2020/04/15/X58rIWbk7wFvsSZ.png" alt=""></p>
<p>这个就是求取一个拓扑序,但是要求拓扑序是最小字典序的,需要对队列进行操作</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>在拓扑排序的基础上,我们把正常用的队列改为最小堆,这样每次获得的0入度节点一定是字典序最小的点,其他的操作和正常的拓扑排序一致,首先找到入度为0的点,然后将其加入到堆,从堆取出一个节点,更新其邻接点入度,如果邻接点的入度为0了,就将邻接点加入到堆,重复循环直到堆空了.</p>
<p>使用堆的拓扑排序复杂度O(NlogN+M)</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">505</span>];<span class="comment">//图</span></span><br><span class="line"><span class="keyword">int</span> edges[<span class="number">505</span>];<span class="comment">//入度</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//最小堆</span></span><br><span class="line"><span class="keyword">int</span> ans [<span class="number">505</span>];<span class="comment">//拓扑序列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(edges,<span class="number">0</span>,<span class="keyword">sizeof</span>(edges));</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> p1,p2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p1,&amp;p2);</span><br><span class="line">            edges[p2]++;<span class="comment">//更新入度</span></span><br><span class="line">            G[p1].push_back(p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)<span class="comment">//找到所有入度为0的点</span></span><br><span class="line">            <span class="keyword">if</span>(edges[i] == <span class="number">0</span>)</span><br><span class="line">                q.push(i);<span class="comment">//放入堆</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;<span class="comment">//用于形成拓扑序</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            ans[cnt++] = temp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[temp])<span class="comment">//更新邻接点</span></span><br><span class="line">                <span class="keyword">if</span>(--edges[i] == <span class="number">0</span>)<span class="comment">//邻接点的入度为0</span></span><br><span class="line">                    q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[<span class="number">0</span>]);<span class="comment">//格式要求</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>拓扑序本质上还是一个贪心,比较好写,可能在取点时会有各种限制,注意一下</p>
<h2 id="C-班长竞选"><a href="#C-班长竞选" class="headerlink" title="C - 班长竞选"></a>C - 班长竞选</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="　题意"></a>　题意</h3><h4 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h4><p><img src="https://i.loli.net/2020/04/15/WEe5rOpKcRaqP24.png" alt=""></p>
<p>这个也是给定一个集合,然后求取传递闭包,问有多少个点能到达给定点,然后输出最多的点</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>之前求闭包用的是floyd,但是这个算法在这里不太行,因为数据是5e3,n^3^的话就超时了,因此需要优化,这里采用的办法是求取强连通分量然后进行缩点.</p>
<p>求取强强联通分量的算法是Kosaraju,跑两遍dfs,时间复杂度是O(n+m),常数会大一些.</p>
<p>具体操作是这样的,首先对全图跑一边dfs,同时记录dfs后续序列.然后根据将后续序列倒过来,按照逆后续序列再跑一遍dfs,这次在反图中进行,这次一个dfs中经过的点都做一样的标记,这样标记相同的点就在一个强连通分量中.</p>
<p>得到了强连通分量,我们就可以进行缩点了,每个强连通分量都变成了一个点,遍历强连通分量中的点,能连接到其他的连通分量就在缩点后的图中加一条边(可能会有重复的边,但是不影响).</p>
<p>我们可以得知每一强连通分量都是互通的,因此有n-1个点支持连通分量内的点(连通分量有n个点),除此之外缩点后的图中还会有其他的连通分量连接过来,因此还要算上他们</p>
<p>这个我们使用dfs来求,缩点时我们添加边改为反向的,这样一个点能到的点都是支持他的.在缩点后的图中跑一边dfs就知道有多少个连通分量支持了,最终把所有支持的都加起来,取最大的那个就行了</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">5005</span>];<span class="comment">//原始的图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Gr[<span class="number">5005</span>];<span class="comment">//反向的原始图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Gs[<span class="number">5005</span>];<span class="comment">//缩点后的图</span></span><br><span class="line"><span class="keyword">int</span> vote[<span class="number">5005</span>];<span class="comment">//最终一个点的票数</span></span><br><span class="line"><span class="keyword">int</span> group[<span class="number">5005</span>];<span class="comment">//强连通分量标记</span></span><br><span class="line"><span class="keyword">int</span> dfs[<span class="number">5005</span>];<span class="comment">//后dfs序</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">5005</span>];<span class="comment">//dfs访问记录</span></span><br><span class="line"><span class="keyword">int</span> dfsCnt;<span class="comment">//用于记录后dfs序</span></span><br><span class="line"><span class="keyword">int</span> temp[<span class="number">5005</span>];<span class="comment">//记录每个强连通分量的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstDFS</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//第一遍后dfs序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i=G[s].begin();i!=G[s].end();i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[*i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[*i] = <span class="number">1</span>;</span><br><span class="line">            firstDFS(*i);</span><br><span class="line">        &#125;</span><br><span class="line">    dfs[dfsCnt++] = s;<span class="comment">//后续</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">groupDFS</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> t)</span><span class="comment">//分组</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    group[s] = t;<span class="comment">//都是一个标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i=Gr[s].begin();i!=Gr[s].end();i++)<span class="comment">//跑反图</span></span><br><span class="line">        <span class="keyword">if</span>(group[*i]==<span class="number">0</span>)<span class="comment">//自带标记</span></span><br><span class="line">            groupDFS(*i,t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> vis[],<span class="keyword">int</span> s)</span><span class="comment">//缩点后的图中,一个连通分量与多少连通分量连接,返回所有连接分量的点的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempAns=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator i=Gs[s].begin();i!=Gs[s].end();i++)</span><br><span class="line">        <span class="keyword">if</span>(vis[*i]==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            vis[*i] = <span class="number">1</span>;</span><br><span class="line">            tempAns+=getNum(vis,*i);<span class="comment">//dfs</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> tempAns+temp[s];<span class="comment">//加上自己的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;t;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        dfsCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">4</span>;i++)</span><br><span class="line">            vote[i]=<span class="number">0</span>,group[i]=<span class="number">0</span>,vis[i]=<span class="number">0</span>,dfs[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            G[i].clear();</span><br><span class="line">            Gr[i].clear();</span><br><span class="line">            Gs[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上述为清空</span></span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            G[a].push_back(b);</span><br><span class="line">            Gr[b].push_back(a);<span class="comment">//反图</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)<span class="comment">//第一次后dfs</span></span><br><span class="line">            &#123;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                firstDFS(i);</span><br><span class="line">            &#125;</span><br><span class="line">        reverse(dfs,dfs+n);<span class="comment">//反转</span></span><br><span class="line">        <span class="keyword">int</span> color = <span class="number">1</span>;<span class="comment">//染色</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(group[dfs[i]]==<span class="number">0</span>)</span><br><span class="line">                groupDFS(dfs[i],color++);</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="keyword">sizeof</span>(temp));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            temp[group[i]]++;<span class="comment">//记录每个强连通分量内点的个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//缩点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator t=G[i].begin();t!=G[i].end();t++)</span><br><span class="line">                <span class="keyword">if</span>(group[i]!=group[*t])</span><br><span class="line">                    Gs[group[*t]].push_back(group[i]);<span class="comment">//可能会重复,无所谓</span></span><br><span class="line">        <span class="keyword">int</span> vis2[color+<span class="number">5</span>];<span class="comment">//访问标记</span></span><br><span class="line">        <span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;color;i++)</span><br><span class="line">            <span class="keyword">if</span>(vis2[i]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis2));<span class="comment">//清空</span></span><br><span class="line">                vis2[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// getNum(vis2,i);</span></span><br><span class="line">                vote[i] = getNum(vis2,i)<span class="number">-1</span>;<span class="comment">//最后减一因为自己不能给自己投</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> maxNum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;color;i++)</span><br><span class="line">            <span class="keyword">if</span>(vote[i]&gt;maxNum)</span><br><span class="line">                maxNum = vote[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>,k+<span class="number">1</span>,maxNum);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;n;i++)<span class="comment">//格式要求,少一个空格</span></span><br><span class="line">            <span class="keyword">if</span>(vote[group[i]]==maxNum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(i++;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">if</span>(vote[group[i]]==maxNum)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这道题还是有点难度的,开始调了好久,没有意识到自己的后dfs序求错了,改了后dfs序就正确了,有趣的是即便后dfs序是错误的,但是还是过了样例,看起来样例参考意义太小了</p>
<h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><blockquote>
<p>这次CSP大翻车,直接爆零,情况十分惨烈</p>
<p>第一题 这个确实错了,想的时候没有把情况想全,忽略了只有两个数的情况</p>
<p>第二题 这个非常可惜,最后三分钟检查出了错误,没改完,明明是能拿满分的</p>
<p>第三题 考场上基本想出做法了,两次二分,但是时间不太够,因此先写了个暴力前6个点,结果<strong>交错了</strong>,我居然把第2题的代码交到了第三题 哎</p>
</blockquote>
<h2 id="HRZ的序列"><a href="#HRZ的序列" class="headerlink" title="HRZ的序列"></a>HRZ的序列</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p><img src="https://i.loli.net/2020/04/17/XQcdpziCewRNKlE.png" alt=""></p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><h4 id="我的"><a href="#我的" class="headerlink" title="我的"></a>我的</h4><p>找出输入中最大的和最小的元素,然后遍历输入,如果这个这数等于最大或者最小直接继续,不等于看看(最大-最小)%2是不是0,是0判断看看输入是不是(最小+最大)/2,不是0则直接输出NO.</p>
<h4 id="另一个"><a href="#另一个" class="headerlink" title="另一个"></a>另一个</h4><p>用一个set来记录,两个元素的时候直接输出YES,三个元素时,判断三者关系,四个及以上输出NO</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> data [<span class="number">10005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,data+j);</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> Max = data[<span class="number">0</span>],Min=data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;n;t++)<span class="comment">//找到max min</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[t]&gt;Max)</span><br><span class="line">                Max = data[t];</span><br><span class="line">            <span class="keyword">if</span>(data[t]&lt;Min)</span><br><span class="line">                Min =data[t];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;n;t++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(data[t]==Max||data[t]==Min))<span class="comment">//是不是max,min</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((Max-Min)%<span class="number">2</span> == <span class="number">1</span>)<span class="comment">//能不能/2,因为要求是整数,不会有小数</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag =<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(data[t]!=Min+(Max-Min)/<span class="number">2</span>)<span class="comment">//不是平均的</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这类题感觉自己不是很会做,有点类似脑筋急转弯的感觉,难度不大,就是想不到,得多加联系</p>
<h2 id="HRZ学英语"><a href="#HRZ学英语" class="headerlink" title="HRZ学英语"></a>HRZ学英语</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p><img src="https://i.loli.net/2020/04/17/WTn6rmvF1ZQDsiI.png" alt=""></p>
<p>给定一个序列,让找到满足要求的区间,并且输出最小字典序</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>这里采取了类似尺取的做法,用一个数组vis记录26个字母对应在给定序列中的下标,一个r指针,一个l指针,每次先移动r指针到指定位置(正好确保l,r之间放满26个字母),每次移动记录r对应字母的下标,如果已经有了下标则代表重复,让l跳转到当前下标的下一个位置,同时l移动的同时把vis置0.然后为r重新设定目标位置,重新开始移动,直到移动到目标位置.</p>
<p>输出要求最小字典序,因此首先l所在位置的字母指示的下标开始在输入序列中遍历,遇到?,去vis中找第一个为0的字母,输出它,同时标记vis.</p>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> data[<span class="number">1000005</span>];<span class="comment">//存储输入</span></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100</span>];<span class="comment">//26个字母对应下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%c"</span>,data+i)!=EOF)</span><br><span class="line">        <span class="keyword">if</span>(data[i]!=<span class="string">'\n'</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(i&lt;= <span class="number">26</span>)<span class="comment">//至少26个字母,i==27</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">1</span>,r= <span class="number">1</span>;<span class="comment">//左右指针</span></span><br><span class="line">    <span class="keyword">int</span> lt=<span class="number">0</span>,rt=<span class="number">26</span>;<span class="comment">//左右指针应该到达的位置</span></span><br><span class="line">    <span class="keyword">while</span>(r-l &lt; <span class="number">26</span>)<span class="comment">//r-l==26就满足条件了</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=lt)<span class="comment">//l最终到达lt+1,但是lt+1没有被清零</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[l] == <span class="string">'?'</span>)<span class="comment">//重置vis</span></span><br><span class="line">                vis[data[l]] = <span class="number">0</span>;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;=rt)<span class="comment">//到达rt后l,r的距离就是26了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[r] != <span class="string">'?'</span>)</span><br><span class="line">                <span class="keyword">if</span>(vis[data[r]] == <span class="number">0</span>)<span class="comment">//没有标记</span></span><br><span class="line">                    vis[data[r]] = r;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    lt = vis[data[r]];<span class="comment">//标记后就要移动l</span></span><br><span class="line">                    rt = lt+<span class="number">26</span>;<span class="comment">//新的位置</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rt&gt;=i)<span class="comment">//到达了末端</span></span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>)   </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//字典序最小</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(data[j] != <span class="string">'?'</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c"</span>,data[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> f=<span class="string">'A'</span>;f&lt;=<span class="string">'Z'</span>;f++)<span class="comment">//找到vis第一个为0的输出</span></span><br><span class="line">                    <span class="keyword">if</span>(vis[f] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"%c"</span>,f);</span><br><span class="line">                        vis[f] = <span class="number">1</span>;<span class="comment">//标记</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>这道题在赛场上没做出来太可惜了,思路是对了,但是最后没有判断好l和r的关系,没写好退出的条件,产生了错误,最终没有过</p>
<h2 id="咕咕东的奇妙序列"><a href="#咕咕东的奇妙序列" class="headerlink" title="咕咕东的奇妙序列"></a>咕咕东的奇妙序列</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p><img src="https://i.loli.net/2020/04/17/Xu3rDvcNzmELR1W.png" alt=""></p>
<p>这道题就是给定了一个规则,我们用这个规则生成了一个序列(当然不可能实际生成出来),求取序列中指定位置的点的值</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>使用两次二分来解</p>
<p>第一次二分是找到要查找的元素在哪一个组(第i组是指123 … i-1 i 这个范围),找到那一组之后还要在二分查找在这一组的哪一个位置</p>
<p>首先我们要知道第i组在序列中是什么位置(第i组结束的位置),我们可以观察规律,很容易发现如果是是第i组,1有i个,2有i-1个….10有i-9个,最终i有1个.然后每个数我们都是知道他们的位数的,现在又知道了个数,就很容易求出第i组的位置了.</p>
<p>但是这样一个数一个数的求,效率比较低,我们可以直接把所有t位的数总个数一次求出了,比如2位的数(10-99)一共90个,然后10的个数到99的个数是一个等差数列,用就和公式直接求就行了,最后*2就是2位数占的位置,其他的类似.我们给出一个t位数,我们可以直接求出1-t-1位数总的数字数,然后用同样的方法求t位数的数字数.</p>
<p>这样我们就能完全知道第i组数在序列中的位置了,然后使用二分求出第一个大于等于给定位置的组,再在组中进行操作.</p>
<p>在组中也是要找到第k个数的位置,,这个简单多了,假设k用m位,从1-m-1位的数可以直接求出来,因为每个数的位数是知道的,每个数只出现一次,t位数有几个都知道(比如1位的9个,2位的一共90个,3位的900个).剩下解决m位有几个,k-(1em)+1就是个数了,乘上m算出数字个数了,全部加起来就是位置了</p>
<p>同样我们也使用二分找到第一个大于等于给定位置的数,最终输出想要的哪一位就行了</p>
<p>复杂度分析$O((log_{10}ST)^2logST)$大致应该是这个复杂度,ST是一个常数,因为每次固定从他开始找,因此是稳定的,第ST组数的结束位置已经大于了数据范围</p>
<h3 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ST 800000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bits</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> num)</span><span class="comment">//计算一个数有几位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;num&gt;<span class="number">0</span>;num=num/<span class="number">10</span>,ans++);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//10的i次方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;i;t++)</span><br><span class="line">        ans*=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">curNum</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> s,<span class="keyword">long</span> <span class="keyword">long</span> e)</span><span class="comment">//计算等差数列和,顺便乘上n</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> n*(e+s)*(s-e+<span class="number">1</span>)/<span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">allNum</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> temp)</span><span class="comment">//计算temp所在的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = bits(temp);<span class="comment">//有几位</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;<span class="comment">//记录位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//1~n-1位有多少个数字</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans+=curNum(<span class="number">1l</span>l*i,temp-power(i<span class="number">-1</span>)+<span class="number">1</span>,temp+<span class="number">1</span>-power(i<span class="number">-1</span>)<span class="number">-9</span>*power(i<span class="number">-1</span>)+<span class="number">1</span>);<span class="comment">//temp-xxx,表示的等差数列开始位置和结束的位置,这个是符合规律的</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans+=curNum(n,temp-power(n<span class="number">-1</span>)+<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//第n位有几个,也是用规律求的等差数列</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">perNum</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> temp)</span><span class="comment">//temp在组内的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = bits(temp);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span>  ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//1~n-1</span></span><br><span class="line">        ans+= i*power(i<span class="number">-1</span>)*<span class="number">9</span>;</span><br><span class="line">    ans+= n*(temp-power(n<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;n;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> l=<span class="number">0</span>,r=ST;<span class="comment">//ST是找的一个数,因为allNum(ST)已经超过了数据范围,ST可以降低复杂度</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tar = <span class="number">0</span>;<span class="comment">//目标</span></span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">if</span>(allNum(mid)&gt;=k)<span class="comment">//找第一个大于k的组</span></span><br><span class="line">            &#123;</span><br><span class="line">                r= mid<span class="number">-1</span>;<span class="comment">//右移</span></span><br><span class="line">                tar = mid;</span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        l=<span class="number">0</span>,r=tar;<span class="comment">//下一次二分</span></span><br><span class="line">        k-=allNum(tar<span class="number">-1</span>);<span class="comment">//第tar组满足,减去allNum(tar-1)就是tar组内的位置了</span></span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(perNum(mid)&gt;=k)<span class="comment">//找到tar组内,第一个大于k的数</span></span><br><span class="line">            &#123;</span><br><span class="line">                r=mid<span class="number">-1</span>;</span><br><span class="line">                tar = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l=mid+<span class="number">1</span>;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        k-=perNum(tar<span class="number">-1</span>);<span class="comment">//减去之后就是在tar这个数内第几个数字了</span></span><br><span class="line">        <span class="built_in">stringstream</span> s;<span class="comment">//方便输出</span></span><br><span class="line">        s&lt;&lt;tar;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        s&gt;&gt;str;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,str[k<span class="number">-1</span>]);<span class="comment">//直接输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>这道题一开始写的暴力,结果交的时候硬是交成了第2题的代码,这是不可忍受的的,以后交的时候一定要检查!!!</p>
<p>对于这道题来说找到了规律不算太难,当时看到这么大数据范围i基本上就能想到是二分这类log的算法了,但是码力不太够,不能在30min之内完全打出来,还是有待提升</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/04/13/Program-week7-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/13/Program-week7-homework/" itemprop="url">Program_week7_homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T22:55:21+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week7-homework"><a href="#week7-homework" class="headerlink" title="week7-homework"></a>week7-homework</h1><h2 id="A-TT-的魔法猫"><a href="#A-TT-的魔法猫" class="headerlink" title="A - TT 的魔法猫"></a>A - TT 的魔法猫</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><h4 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h4><p><img src="https://i.loli.net/2020/04/13/f5x2hgARbe7BKrE.png" alt=""></p>
<p>这道题就是求一个传递闭包,题目中给出胜负关系可以看成一对序偶,相互之间具有传递关系,给出基本的几个序偶,然后让求取改集合的传递闭包,然后看看闭包中有多少个元素</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>首先我们把这个输赢关系建成图,使用二维矩阵直接存储这个图,N个人代表矩阵大小是N*N,M个关系则代表图中有M条边,A B,代表A赢过B,建立一条A到B的边,如果B能到C则也有A到C的边</p>
<p>将图按照给定的元素初始化后我们对这张图跑floyd-warshall.不过要把松弛条件改一下,不是最短路径了,而是只要能到达则将数组中对应的位置改为1.</p>
<p>注意在这种情况下能够进行剪枝,如果在判断i经过j能能不能到达新节点时,若i直接不能到达j,则跳过.经过剪枝后时间复杂度会降低不少.</p>
<p>最后计算未知的数量,首先使用组合的知识计算出多少场比赛$C^2_n$,减去矩阵中1的数量,这样就能得到未知的场数</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector&lt;int&gt; G[502];</span></span><br><span class="line"><span class="keyword">int</span> G[<span class="number">502</span>][<span class="number">502</span>];<span class="comment">//二维矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(G,<span class="number">0</span>,<span class="keyword">sizeof</span>(G));<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            G[a][b] = <span class="number">1</span>;<span class="comment">//A赢B,A-&gt;B的路   </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n+<span class="number">1</span>;k++)<span class="comment">//经过第k个</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;n+<span class="number">1</span>;t++)</span><br><span class="line">                <span class="keyword">if</span>(G[t][k]==<span class="number">1</span>)<span class="comment">//剪枝,不能到达就不继续了,正常floyd也可以有</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> e=<span class="number">0</span>;e&lt;n+<span class="number">1</span>;e++)</span><br><span class="line">                        <span class="keyword">if</span>(G[k][e]==<span class="number">1</span>)<span class="comment">//更新,可能会重复,但不影响正确</span></span><br><span class="line">                            G[t][e] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;n+<span class="number">1</span>;p++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> q=<span class="number">0</span>;q&lt;n+<span class="number">1</span>;q++)</span><br><span class="line">                <span class="keyword">if</span>(G[p][q] == <span class="number">1</span>)</span><br><span class="line">                    ans++;<span class="comment">//统计已知场数</span></span><br><span class="line">        ans = ((n*(n<span class="number">-1</span>))/<span class="number">2</span> ) - ans;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题一开始交的时候没有考虑剪枝的情况(虽然上课讲了),然后就T了,后来想起来可以剪枝降低复杂度,就加了剪枝,然后就过了,以后还是要写带剪枝的floyd.</p>
<h2 id="B-TT-的旅行日记"><a href="#B-TT-的旅行日记" class="headerlink" title="B - TT 的旅行日记"></a><a href="https://vjudge.net/problem/UVA-11374" target="_blank" rel="noopener">B - TT 的旅行日记</a></h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><h4 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h4><p><img src="https://i.loli.net/2020/04/13/sQGrTYqmtDAE7wS.png" alt=""></p>
<p>这道题是想说现在有一张普通车的图,然后我们把它想成两张上下平行的图,在这两张图之间在构建一个图,新的图就是VIP路线,VIP相当于把两张图连接起来了,但是VIP路线只能走一次,从上面的图下来就没法上去了,但是可以选择不下去,一直走上面那张图.</p>
<p>最终求从起点开始到终点的最短路径长度和路线,只允许走一次VIP</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>使用变形的堆优Dijkstra来解,图使用邻接链表(vector其实是邻接数组).</p>
<p>首先我们已经知道图的结构,两张一样的图上下平行放置,然后两张平行图中放置了VIP路线,将两张图连接起来,但是只能走一遍.</p>
<p>因此我们记录最小距离dis要进新改变变为dis[0][]和dis[1][],第一维的0,1代表是否经过了VIP路线.</p>
<p>我们使用堆优化的dijkstra,因此需要建一个最小堆,堆中放posi类型,记录待更新点的前驱节点,该节点,从源点到该节点的长度,和有没有走过VIP.对于没走过VIP的节点,从堆中取出更新时可以走普通的路更新dis[0],也可以走VIP更新dis[1],走过VIP的只能走普通路,更新dis[1]</p>
<p>我们还需要判断一个点是否已经最短了(从堆中取出来),同时为了顺便记录前驱节点(用于输出路线),我们使用pre数组记录一个点的前驱节点,对于走过VIP的点我们使用pair\<int,int>来记录pre2,因为除了前驱点之外还需要知道前驱点是通过VIP还是普通路线来的.如果pre中不为0则代表这个点已经被走过了,从堆中取出时就不操作了.</p>
<p>正常情况下从堆中取出点,首先判断是不是走过VIP的点,然后看看这个点是不是已经走过了,然后对于没走过VIP点,松弛时一是使用普通的路进行松弛,二是使用VIP路进行松弛,对于走过VIP的点就只是用普通路进行松弛了.</p>
<p>最终我们能得到只走普通路的最短路和走过一次VIP的最短路,然后看看这两个那个小就输出那个,路线的话只走普通路就直接输出了,走过VIP的话要注意是从那个点走的VIP,那个点之前的路线还是得用只走普通路的路线.</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">posi</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> s,e;<span class="comment">//前驱和待更新的</span></span><br><span class="line">    <span class="keyword">int</span> weight;<span class="comment">//源点到e的长度</span></span><br><span class="line">    <span class="keyword">int</span> tag;<span class="comment">// 有没有走过VIP</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> posi&amp; op) <span class="keyword">const</span>&#123;<span class="comment">//重载</span></span><br><span class="line">        <span class="keyword">return</span> weight&lt;op.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; G[<span class="number">2</span>][<span class="number">502</span>];<span class="comment">//普通路线和VIP路线图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre0 [<span class="number">502</span>];<span class="comment">//只走普通路线的前驱节点</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pre1[<span class="number">502</span>];<span class="comment">//走过VIP的前驱节点</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">2</span>][<span class="number">502</span>];<span class="comment">//两个最短路</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;posi &gt; q;<span class="comment">// frist </span></span><br><span class="line"><span class="keyword">int</span> over = <span class="number">0</span>;<span class="comment">//用VIP的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">path</span><span class="params">(<span class="keyword">int</span> s,<span class="keyword">int</span> e,<span class="keyword">int</span> i,<span class="keyword">int</span> flag)</span><span class="comment">//输出路线</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!flag)<span class="comment">//flag是有没有使用VIP</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=s)<span class="comment">//起点</span></span><br><span class="line">        &#123;</span><br><span class="line">            path(s,e,pre0[i],flag);<span class="comment">//输出前驱</span></span><br><span class="line">            <span class="keyword">if</span>(i == e) <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);<span class="comment">//终点,特判是因为输出格式</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,s);<span class="comment">//输出起点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//走了VIP</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre1[i].second==<span class="number">1</span>)<span class="comment">//从这点走的VIP</span></span><br><span class="line">            &#123;</span><br><span class="line">                over = pre1[i].first;<span class="comment">//设置</span></span><br><span class="line">                path(s,e,pre1[i].first,<span class="number">0</span>);<span class="comment">//输出前驱</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                path(s,e,pre1[i].first,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==e) <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> s,<span class="keyword">int</span> e)</span><span class="comment">//总的输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>,length;</span><br><span class="line">    over = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dis[<span class="number">0</span>][e]&lt;dis[<span class="number">1</span>][e])</span><br><span class="line">        length = dis[<span class="number">0</span>][e];<span class="comment">//只走普通路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;<span class="comment">//走了VIP</span></span><br><span class="line">        length = dis[<span class="number">1</span>][e];</span><br><span class="line">    &#125;</span><br><span class="line">    path(s,e,e,flag);<span class="comment">//输出从s到e的路线,flag表示有没有用VIP</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(over == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Ticket Not Used\n"</span>);<span class="comment">//没用VIP</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,over);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,s,e;</span><br><span class="line">    <span class="keyword">int</span> nextLine = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;s,&amp;e)!=EOF)<span class="comment">//读到文件结尾</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nextLine) <span class="built_in">printf</span>(<span class="string">"\n"</span>);<span class="comment">//格式需求,最终不输出回车</span></span><br><span class="line">        nextLine = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(pre0,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre0));</span><br><span class="line">        <span class="built_in">memset</span>(pre1,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre1));</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">                G[j][i].clear();</span><br><span class="line">        <span class="keyword">int</span> k,m;</span><br><span class="line">        <span class="keyword">int</span> x,y,z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            G[<span class="number">0</span>][x].push_back(make_pair(y,z));</span><br><span class="line">            G[<span class="number">0</span>][y].push_back(make_pair(x,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            G[<span class="number">1</span>][x].push_back(make_pair(y,z));</span><br><span class="line">            G[<span class="number">1</span>][y].push_back(make_pair(x,z));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上述为构建图</span></span><br><span class="line">        dis[<span class="number">0</span>][s] = <span class="number">0</span>,dis[<span class="number">1</span>][s] = <span class="number">0</span>;<span class="comment">//初始化源点</span></span><br><span class="line">        <span class="comment">// pre0[s]=s,pre1[s].first=s;</span></span><br><span class="line">        q.push(&#123;s,s,<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="comment">//将起点放入堆</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            posi cur = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur.tag == <span class="number">0</span>)<span class="comment">//没有走过VIP</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre0[cur.e]!=<span class="number">0</span>)<span class="comment">//已经走过了</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                pre0[cur.e] = cur.s;<span class="comment">//前驱</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">auto</span> i:G[<span class="number">0</span>][cur.e])<span class="comment">//普通图</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nxt = i.first,weight = i.second;</span><br><span class="line">                    <span class="keyword">if</span>(dis[<span class="number">0</span>][nxt]&gt; -cur.weight+weight)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dis[<span class="number">0</span>][nxt] = -cur.weight+weight;</span><br><span class="line">                        q.push(&#123;cur.e,nxt,-dis[<span class="number">0</span>][nxt],<span class="number">0</span>&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[<span class="number">1</span>][cur.e])<span class="comment">//VIP图</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nxt = i.first,weight = i.second;</span><br><span class="line">                    <span class="keyword">if</span>(dis[<span class="number">1</span>][nxt]&gt; -cur.weight+weight)<span class="comment">//cur.weight是负数</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dis[<span class="number">1</span>][nxt] = -cur.weight+weight;</span><br><span class="line">                        q.push(&#123;cur.e,nxt,-dis[<span class="number">1</span>][nxt],<span class="number">2</span>&#125;);<span class="comment">//这里放负的,因为stl默认最大堆,这里放进去时标记了tag为2代表从这个点走的VIP</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//走过了VIP</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(pre1[cur.e].first != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                pre1[cur.e].first = cur.s;<span class="comment">//前驱</span></span><br><span class="line">                <span class="keyword">if</span>(cur.tag == <span class="number">2</span>) pre1[cur.e].second = <span class="number">1</span>;<span class="comment">//记录前驱时 前驱通过VIP到的cur</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[<span class="number">0</span>][cur.e])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> nxt = i.first,weight = i.second;</span><br><span class="line">                    <span class="keyword">if</span>(dis[<span class="number">1</span>][nxt]&gt;-cur.weight+weight)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dis[<span class="number">1</span>][nxt] = -cur.weight+weight;</span><br><span class="line">                        q.push(&#123;cur.e,nxt,-dis[<span class="number">1</span>][nxt],<span class="number">1</span>&#125;);<span class="comment">//tag为1,代表走过了VIP但是不是这次走的VIP</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output(n,s,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题比较难的地方是不太容易想到更新的条件.</p>
<h2 id="C-TT-的美梦"><a href="#C-TT-的美梦" class="headerlink" title="C - TT 的美梦"></a><a href="https://vjudge.net/problem/LightOJ-1074" target="_blank" rel="noopener">C - TT 的美梦</a></h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><h4 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h4><p><img src="https://i.loli.net/2020/04/13/3BSXJC6xrT7hZeG.png" alt=""></p>
<p>这道题看起来还是求单源最短路的问题,但是这个是有负边的负环的情况,就不能使用Dijkstra了,必须使用BF或者SPFA.</p>
<p>现在提供一个图和一个源点,然后求出源点到图中每个点的距离,如果不存在或者该点在负环上还有距离小于3就输出?,否则输出距离</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>本题使用的SFPA来解决,图还是使用邻接数组存</p>
<p>首先根据题意建立图,注意图是有向的,然后还要注意图中是有负边的</p>
<p>然后从源点开始跑SFPA,使用一个队列记录每次被成功松弛的点,每次取队列中的点对该点的邻接点进行松弛,成功加入队列,直到队列空,除此之外因为有负环我们还要注意判断负环,条件是一个点进入队列的次数大于了图中节点数.</p>
<p>但是这样我们只能知道有负环,但是不知道负环在那里,这时使用一个pre数组记录每个点的前驱节点,如果是在一个负环中,那么在pre数组中也必然形成一个环.因此我们通过dfs pre数组就能判断一个点是不是在负环中.在负环中的点就输出”?”</p>
<p>不能到达的点和小于3的点都输出”?”</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; G[<span class="number">202</span>];<span class="comment">//图结构</span></span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">202</span>];<span class="comment">//每个点的繁荣程度</span></span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">202</span>];<span class="comment">//距离</span></span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">202</span>];<span class="comment">//进队次数</span></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">202</span>];<span class="comment">//前驱节点</span></span><br><span class="line"><span class="keyword">int</span> inq[<span class="number">202</span>];<span class="comment">//入队情况</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power3</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;<span class="keyword">return</span> t*t*t;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">neCircle</span><span class="params">(<span class="keyword">int</span> t,<span class="keyword">int</span> flag)</span><span class="comment">//判断是否是负环中点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">0</span>)<span class="comment">//flag等于0代表没有负环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)<span class="comment">//走出去了,该点不在负环上</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(t == flag)<span class="comment">//转回来了,有负环</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> neCircle(pre[t],flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> f=<span class="number">0</span>;f&lt;t;f++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(weight,<span class="number">0</span>,<span class="keyword">sizeof</span>(weight));</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">127</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">        <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> n,m,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)<span class="comment">//从 1 开始</span></span><br><span class="line">            G[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,weight+<span class="number">1</span>+i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)<span class="comment">//有向边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a,b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">            G[a].push_back(make_pair(b,power3(weight[b]-weight[a])));<span class="comment">//边权公式</span></span><br><span class="line">            <span class="comment">// G[b].push_back(make_pair(a,power3(weight[a]-weight[b])));</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//SPFA队列</span></span><br><span class="line">        q.push(make_pair(<span class="number">1</span>,<span class="number">1</span>));<span class="comment">//源点,pair&lt;int,int&gt;第一个是要访问的点,第二个是访问点的前驱</span></span><br><span class="line">        dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        pre[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        inq[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; curNode =q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> cur = curNode.first;</span><br><span class="line">            pre[cur] = curNode.second;<span class="comment">//记录前驱</span></span><br><span class="line">            <span class="keyword">if</span>(++cnt[cur]&gt;n)<span class="comment">//负环退出</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = cur;<span class="comment">//记录负环退出点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inq[cur] = <span class="number">0</span>;<span class="comment">//不在队中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[cur])<span class="comment">//遍历其邻接点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> nxt=i.first,Wei = i.second;<span class="comment">//点和边权</span></span><br><span class="line">                <span class="keyword">if</span>(dis[nxt]&gt;dis[cur]+Wei)<span class="comment">//松弛成功</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dis[nxt] = dis[cur]+Wei;</span><br><span class="line">                    <span class="keyword">if</span>(inq[nxt]== <span class="number">0</span>)<span class="comment">//不在队中</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        q.push(make_pair(nxt,cur));</span><br><span class="line">                        inq[nxt] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d:\n"</span>,f+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> nxt;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nxt);</span><br><span class="line">            <span class="keyword">if</span>(dis[nxt]&gt;<span class="number">10000000</span>||dis[nxt]&lt;<span class="number">3</span>)<span class="comment">//无法到达和太短</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"?\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">if</span>(neCircle(nxt,flag))<span class="comment">//负环</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[nxt]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"?\n"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>负环中点的判断可以使用前驱节点来判断,一开始确实没想到,之后就用这个方法去判断了</p>
<p>还有一个问题,如果图中有两个负环怎么判断,我这个代码没有讨论两个负环的情况,然后过了,但是不是很明白怎么判断多个负环,而且这个题中好像也没有涉及到两个负环的情况</p>
<h1 id="CSP月模拟"><a href="#CSP月模拟" class="headerlink" title="CSP月模拟"></a>CSP月模拟</h1><h2 id="201604-3-路径"><a href="#201604-3-路径" class="headerlink" title="201604-3 路径"></a>201604-3 路径</h2><blockquote>
<p>习惯误人 !!!</p>
</blockquote>
<h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p><img src="https://i.loli.net/2020/04/16/DpKyOB9hJWqrzfw.png" alt=""></p>
<p>题意其实不难,就是纯模拟,模拟cd的操作,规范一个目录</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>首先在将读入的字符串按照’/‘进行分割存入到vector中,读取使用getchar,因为会有空的情况,字符串使用string存,当字符串开头是’/‘时,向字符串头部加一个’root’.vector名为strPart</p>
<p>这样我们就有了一个没有’/‘的字符串数组.我们开一个string的vector curPart用于记录最终不带’/‘的路径.  如果数组开头是不是’root’,是相对路径,我们把之前处理过的当前路径(pwd)赋给curPart,否则让curPart为空,然后遍历strPart,对于”.”直接continue,对于”..”先判断curPart元素个数大于1就pop_back,否则不动,其他的就是真正的文件名了,加入到curPart中,最终返回curPart.</p>
<p>除此之外我们还要主意当空字符串的时候(就一个’\n’),直接输出当前路径就行了</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> data;<span class="comment">//每次读入</span></span><br><span class="line"><span class="built_in">string</span> pwd;<span class="comment">//当前路径</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pwdPart;<span class="comment">//处理完的当前路径</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">genFileStruct</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; originStr,<span class="keyword">int</span> choose=<span class="number">0</span>)</span><span class="comment">//choose是为了pwd准,不删除root</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strPart;<span class="comment">//首先分段</span></span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; curPart;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">newStr</span><span class="params">(<span class="string">"root"</span>)</span></span>;<span class="comment">//加上root</span></span><br><span class="line">    <span class="keyword">if</span>(originStr.size()==<span class="number">0</span>||originStr[<span class="number">0</span>] == <span class="string">'/'</span>)</span><br><span class="line">        newStr = newStr+originStr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newStr = originStr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> i:newStr)<span class="comment">//开始分离开每个文件(夹)名 .. 和 .</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="string">'/'</span>)</span><br><span class="line">            temp+=i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp.size()&gt;<span class="number">0</span>)<span class="comment">//不加入空字符串</span></span><br><span class="line">                strPart.push_back(temp);</span><br><span class="line">            temp.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(strPart[<span class="number">0</span>]!=<span class="string">"root"</span>)<span class="comment">//不是root则代表是相对路径</span></span><br><span class="line">        curPart = pwdPart;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span> i:strPart)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="string">".."</span>)<span class="comment">//弹栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(curPart.size()&gt;<span class="number">1</span>)<span class="comment">//不能把root弹了</span></span><br><span class="line">                curPart.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="string">"."</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//压栈</span></span><br><span class="line">            curPart.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (choose == <span class="number">1</span>)<span class="comment">//不删root</span></span><br><span class="line">        <span class="keyword">return</span> curPart;</span><br><span class="line">    curPart.erase(curPart.begin());<span class="comment">//把root删了,方便输出</span></span><br><span class="line">    <span class="keyword">return</span> curPart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">readInput</span><span class="params">()</span><span class="comment">//getchar读取</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>((c=getchar())!=<span class="string">'\n'</span>)</span><br><span class="line">        temp=temp+c;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    getchar();</span><br><span class="line">    pwd = readInput();</span><br><span class="line">    pwdPart = genFileStruct(pwd+<span class="string">"/"</span>,<span class="number">1</span>);<span class="comment">//加/是为了方便分离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;n;t++)</span><br><span class="line">    &#123;</span><br><span class="line">        data.clear();</span><br><span class="line">        data = readInput();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(data.size() != <span class="number">0</span>)</span><br><span class="line">            ans = genFileStruct(data+<span class="string">"/"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//空字符串</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = pwdPart;<span class="comment">//当前路径</span></span><br><span class="line">            ans.erase(ans.begin());<span class="comment">//删除root</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.size()==<span class="number">0</span>)<span class="comment">//全是/的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"/"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> i:ans)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"/"</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这道题比较简单,一开始很快就写完了,结果60分,读一遍题,发现没处理空字符串的情况,加上70分,然后测了好长时间不知道原因.后来在读一边题</p>
<p><img src="https://i.loli.net/2020/04/16/Ph4CqpM8kYNyXd7.png" alt=""></p>
<p>只要是不以’/‘开头的都是相对路径,因此不用输./也是从当前路径开始的,之前敲命令习惯性按table,补全的全是带./的,完全没有意识到会有不带./的情况😭然后改了一下判断条件就过了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/28/Program-week6-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/28/Program-week6-homework/" itemprop="url">Program-week6-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-28T22:38:31+08:00">
                2020-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week6-csp"><a href="#week6-csp" class="headerlink" title="week6-csp"></a>week6-csp</h1><h2 id="A-掌握魔法の东东-II"><a href="#A-掌握魔法の东东-II" class="headerlink" title="A - 掌握魔法の东东 II"></a>A - 掌握魔法の东东 II</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少</p>
<p><img src="https://i.loli.net/2020/03/28/tdnqbSlCupaZhXr.png" alt=""></p>
<center>9种情况</center>

<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.</p>
<p>这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种</p>
<ol>
<li>首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了</li>
<li>和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量</li>
<li>判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的</li>
<li>首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能</li>
<li>首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行</li>
<li>这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对</li>
<li>注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个</li>
<li>同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个</li>
<li>计算出总的情况数,减去上面的就行了</li>
</ol>
<p>这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span>];<span class="comment">//1 start</span></span><br><span class="line"><span class="keyword">int</span> A,B;<span class="comment">//A是牌的总大小,B是牌的花色数</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; curCard[<span class="number">2</span>];<span class="comment">//记录先摸的两张牌</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comb</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span><span class="comment">//计算组合数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> answer = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b;i++)</span><br><span class="line">        answer*=(a-i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b;i++)</span><br><span class="line">        answer/=(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(answer&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].second!=curCard[<span class="number">1</span>].second||<span class="built_in">abs</span>(curCard[<span class="number">0</span>].first-curCard[<span class="number">1</span>].first)&gt;<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> max = curCard[<span class="number">0</span>].first&gt;curCard[<span class="number">1</span>].first?curCard[<span class="number">0</span>].first:curCard[<span class="number">1</span>].first;<span class="comment">//取出两张牌中大的和小的</span></span><br><span class="line">    <span class="keyword">int</span> min = curCard[<span class="number">0</span>].first&lt;curCard[<span class="number">1</span>].first?curCard[<span class="number">0</span>].first:curCard[<span class="number">1</span>].first;</span><br><span class="line">    <span class="keyword">int</span> up = min+<span class="number">4</span>&gt;A<span class="number">-1</span>?A<span class="number">-1</span>:min+<span class="number">4</span>;<span class="comment">//上界</span></span><br><span class="line">    <span class="keyword">int</span> down = max<span class="number">-4</span>&lt;<span class="number">0</span>?<span class="number">0</span>:max<span class="number">-4</span>;<span class="comment">//下界</span></span><br><span class="line">    ans[<span class="number">1</span>] = up-down+<span class="number">1</span><span class="number">-5</span>+<span class="number">1</span>;<span class="comment">//窗口的个数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].first==curCard[<span class="number">1</span>].first||<span class="built_in">abs</span>(curCard[<span class="number">0</span>].first-curCard[<span class="number">1</span>].first)&gt;<span class="number">4</span>)<span class="comment">//不需要花色了,但是前两张牌大小不能相同</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> max = curCard[<span class="number">0</span>].first&gt;curCard[<span class="number">1</span>].first?curCard[<span class="number">0</span>].first:curCard[<span class="number">1</span>].first;</span><br><span class="line">    <span class="keyword">int</span> min = curCard[<span class="number">0</span>].first&lt;curCard[<span class="number">1</span>].first?curCard[<span class="number">0</span>].first:curCard[<span class="number">1</span>].first;</span><br><span class="line">    <span class="keyword">int</span> up = min+<span class="number">4</span>&gt;A<span class="number">-1</span>?A<span class="number">-1</span>:min+<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> down = max<span class="number">-4</span>&lt;<span class="number">0</span>?<span class="number">0</span>:max<span class="number">-4</span>;</span><br><span class="line">    ans[<span class="number">2</span>] = (up-down+<span class="number">1</span><span class="number">-5</span>+<span class="number">1</span>)*B*B*B - ans[<span class="number">1</span>];<span class="comment">//容斥要求减掉共同部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].second!=curCard[<span class="number">1</span>].second)<span class="comment">//不同花色直接退出</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ans[<span class="number">3</span>] = comb(A<span class="number">-2</span>,<span class="number">3</span>)-ans[<span class="number">1</span>];<span class="comment">//要求花色相同,但是大小无限制</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B&lt;<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].first==curCard[<span class="number">1</span>].first)</span><br><span class="line">        ans[<span class="number">4</span>] =(A<span class="number">-1</span>)*B;<span class="comment">//后选的牌有两张和先摸的相同,剩下的一张随便</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans[<span class="number">4</span>] = <span class="number">2</span>;<span class="comment">//只能于先摸的其中一张相同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">5</span>] =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].first==curCard[<span class="number">1</span>].first)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">5</span>]+= comb(B,<span class="number">2</span>)*(A<span class="number">-1</span>)*comb(B<span class="number">-2</span>,<span class="number">1</span>);<span class="comment">//先摸的为3张,后摸的为2张</span></span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">3</span>)<span class="comment">//后面抽的为3,前面为2,对于3种花色</span></span><br><span class="line">            ans[<span class="number">5</span>]+=(A<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">4</span>)<span class="comment">//4种花色</span></span><br><span class="line">            ans[<span class="number">5</span>]+=(A<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//抽到的牌不同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">3</span>)</span><br><span class="line">            ans[<span class="number">5</span>]+=<span class="number">2</span>*<span class="number">2</span>*<span class="number">1</span>;<span class="comment">//2选1</span></span><br><span class="line">        <span class="keyword">if</span>(B==<span class="number">4</span>)</span><br><span class="line">            ans[<span class="number">5</span>]+=<span class="number">2</span>*<span class="number">3</span>*<span class="number">3</span>;<span class="comment">//3选2.3选1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].first==curCard[<span class="number">1</span>].first)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">6</span>]+=comb(A<span class="number">-1</span>,<span class="number">2</span>)*B*comb(B,<span class="number">2</span>)*<span class="number">2</span>;<span class="comment">//先摸的两两张必然是对,剩下的3张中出一个对</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">6</span>]+=comb(A<span class="number">-2</span>,<span class="number">1</span>)*comb(B<span class="number">-1</span>,<span class="number">1</span>)*comb(B<span class="number">-1</span>,<span class="number">1</span>)*B+<span class="number">2</span>*comb(A<span class="number">-2</span>,<span class="number">1</span>)*comb(B,<span class="number">2</span>)*(B<span class="number">-1</span>);<span class="comment">//对子都在先抽的中,或者先抽的中只有一个对</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B&lt;<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].first==curCard[<span class="number">1</span>].first)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">7</span>]+=comb(A<span class="number">-1</span>,<span class="number">2</span>)*comb(B<span class="number">-2</span>,<span class="number">1</span>)*B*B;<span class="comment">//只能是先摸的两张是3张</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">7</span>]+=comb(A<span class="number">-2</span>,<span class="number">1</span>)*B*comb(B<span class="number">-1</span>,<span class="number">2</span>)*<span class="number">2</span>+comb(A<span class="number">-2</span>,<span class="number">1</span>)*comb(B,<span class="number">3</span>);<span class="comment">//先摸的有一个是3张的,或者都不是</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">8</span>] =<span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curCard[<span class="number">0</span>].first==curCard[<span class="number">1</span>].first)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">8</span>]+= comb(A<span class="number">-1</span>,<span class="number">3</span>)*B*B*B;<span class="comment">//后抽的三张随便了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">8</span>]+= comb(A<span class="number">-2</span>,<span class="number">2</span>)*B*B*comb(B<span class="number">-1</span>,<span class="number">1</span>)*<span class="number">2</span>+comb(A<span class="number">-2</span>,<span class="number">2</span>)*B*comb(B,<span class="number">2</span>)*<span class="number">2</span>;<span class="comment">//先抽的两张中有一个是2,或者都不是2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">con9</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> all = comb(A*B<span class="number">-2</span>,<span class="number">3</span>)<span class="comment">//总的情况数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        all -= ans[i];<span class="comment">//去掉其他的</span></span><br><span class="line">    ans[<span class="number">9</span>]= all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;A,&amp;B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;curCard[i].first,&amp;curCard[i].second);</span><br><span class="line">    con1();</span><br><span class="line">    con2();</span><br><span class="line">    con3();</span><br><span class="line">    con4();</span><br><span class="line">    con5();</span><br><span class="line">    con6();</span><br><span class="line">    con7();</span><br><span class="line">    con8();</span><br><span class="line">    con9();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i+<span class="number">1</span>]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>高中做题做习惯了,一看见这种形式就直接用排列组合了,但是在CPU中遍历方便的多,而且数据规模很小,不如直接遍历.直接遍历还不会出现排列组合没考虑全的情况,这道题写的有点麻烦了.</p>
<h1 id="week6-homework"><a href="#week6-homework" class="headerlink" title="week6-homework"></a>week6-homework</h1><h2 id="A-氪金带东"><a href="#A-氪金带东" class="headerlink" title="A - 氪金带东"></a>A - 氪金带东</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>本题的意思是求取一个数中任意一个点到离它最远的点的距离</p>
<p>PS: 我觉得题中的说法稍微有点问题,应该指明没有回路,有回路的话一直绕圈不会有最长的路径,我做的时候是把这个图当成一个树来解决的.</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>首先我们有求取树的直径的方法,就是首先从任意一个点出发,用BFS,DFS(必须遍历一边,类似Dij的贪心算法是不行的,因为局部最优不等于全局最优)找到距离该点最远的一个点A,然后从A开始找到离A最远的点B,A,B之间的距离就是树的直径,这个可以用反正法进行证明.</p>
<p>我们要做的是在这个基础上进行一些改动,从A到B的遍历中,记录每一个点距离A的最远距离,在从B开始一次遍历,记录其他点到B的最远距离,然后最远的距离是A,B中最远的哪一个.</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> one[<span class="number">10002</span>];<span class="comment">//记录到A的距离</span></span><br><span class="line"><span class="keyword">int</span> two[<span class="number">10002</span>];<span class="comment">//记录到B的距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">10002</span>];<span class="comment">//记录访问情况</span></span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; G[<span class="number">10002</span>];<span class="comment">//邻接链表存储树</span></span><br><span class="line"></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; A;<span class="comment">//第一个是编号,第二个是最长距离</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfsFind</span><span class="params">()</span><span class="comment">//第一次找到A</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//务必初始化</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//第一个是编号,第二个是最长距离</span></span><br><span class="line">    q.push(make_pair(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    pair&lt;int,int&gt; maxPair(0,0);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())<span class="comment">//BFS实现</span></span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp.second&gt;maxPair.second)<span class="comment">//最远的点</span></span><br><span class="line">            maxPair = &#123;temp.first,temp.second&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[temp.first])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i.first]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i.first] = <span class="literal">true</span>;</span><br><span class="line">                q.push(make_pair(i.first,i.second+temp.second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A = &#123;maxPair.first,<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS1</span><span class="params">()</span><span class="comment">//从A找到B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//第一个是编号,第二个是最长距离</span></span><br><span class="line">    q.push(A);</span><br><span class="line">    vis[A.first] = <span class="literal">true</span>;</span><br><span class="line">    pair&lt;int,int&gt; maxPair(A.first,0);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(temp.second&gt;maxPair.second)</span><br><span class="line">            maxPair = &#123;temp.first,temp.second&#125;;</span><br><span class="line">        one[temp.first] = temp.second;<span class="comment">//每个点之访问一遍,这一边就是最远距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[temp.first])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i.first]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i.first] = <span class="literal">true</span>;</span><br><span class="line">                q.push(make_pair(i.first,i.second+temp.second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    B = &#123;maxPair.first,<span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));<span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q;<span class="comment">//第一个是编号,第二个是最长距离</span></span><br><span class="line">    q.push(make_pair(B.first,<span class="number">0</span>));</span><br><span class="line">    vis[B.first] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        two[temp.first] = temp.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i:G[temp.first])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i.first]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[i.first] = <span class="literal">true</span>;</span><br><span class="line">                q.push(make_pair(i.first,i.second+temp.second));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(one,<span class="number">0</span>,<span class="keyword">sizeof</span>(one));</span><br><span class="line">        <span class="built_in">memset</span>(two,<span class="number">0</span>,<span class="keyword">sizeof</span>(two));  </span><br><span class="line">        <span class="keyword">int</span> point,weight;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;point,&amp;weight);</span><br><span class="line">            G[i].push_back(make_pair(point<span class="number">-1</span>,weight));</span><br><span class="line">            G[point<span class="number">-1</span>].push_back(make_pair(i,weight));</span><br><span class="line">        &#125;</span><br><span class="line">        bfsFind();<span class="comment">//3遍BFS</span></span><br><span class="line">        BFS1();</span><br><span class="line">        BFS2();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,one[i]&gt;two[i]?one[i]:two[i]);<span class="comment">//选出最远的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这个题的实现方式上也有点意思,首先虽然是一个树,但是还是按照图存储的,访问的时候是记录vis,确保是一个连通无回路的树,相当于我们能把任意一个节点当成根节点,遍历整个树,纯的树一般是一种有向图,因此不能从任意一个点出发访问.</p>
<p>一个连通图BFS一遍或者DFS一遍必定得到一个生成树.</p>
<h2 id="B-戴好口罩！"><a href="#B-戴好口罩！" class="headerlink" title="B - 戴好口罩！"></a>B - 戴好口罩！</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>给定n个数,然后给定m个集合,集合中的数字属于一个等价类,问和0同处一个等价类的元素有多少个</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这道题直接用并查集解决就可以,同一个集合的是一类,不断合并,最终求出0号所在的集合,然后统计出属于整个集合的元素的个数</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> same[<span class="number">30002</span>];<span class="comment">//并查集所用的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i!=same[i])</span><br><span class="line">        <span class="keyword">return</span> same[i] = find(same[i]);<span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span><span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(i) == find(j))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    same[find(j)] = find(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>&amp;&amp;n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//初始化</span></span><br><span class="line">            same[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> num;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">            <span class="keyword">int</span> pre,temp;</span><br><span class="line">            <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pre);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;num;t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                uni(pre,temp);<span class="comment">//集合中合并</span></span><br><span class="line">                pre = temp;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//same中和0号同一个元素的个数</span></span><br><span class="line">        <span class="keyword">int</span> tar = find(<span class="number">0</span>);<span class="comment">//0号所在的集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//遍历一遍same</span></span><br><span class="line">            <span class="keyword">if</span>(find(i) == tar)</span><br><span class="line">                count++;<span class="comment">//总数增加</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>并查集实现要加上路径压缩.</p>
<h2 id="C-掌握魔法の东东-I"><a href="#C-掌握魔法の东东-I" class="headerlink" title="C - 掌握魔法の东东 I"></a>C - 掌握魔法の东东 I</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>现在有一个图,途中有n个点,现在让n个点上要有水,水可以是通过其他节点送得,需要边权的耗费,也可以是直接获得,需要$W_i$的耗费(题中给出),问最小耗费是多少</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这道题需要抽象一下,首先直接获得或者其他节点送的都是要耗费,因此二者是等价的,我们开一个节点代表水,把每个点都和水连接,边权就是$W_i$,题意想要的就是每个点都与水联通,这个就是生成树的问题了,直接用最小生成树就行了</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//kruskal实现最小生成树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>//边权</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp; op) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> w&lt;op.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; G[<span class="number">302</span>];<span class="comment">//图</span></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">302</span>];<span class="comment">//水与每个点的权重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> same[<span class="number">302</span>];<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i!=same[i])</span><br><span class="line">        <span class="keyword">return</span> same[i] = find(same[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(i) == find(j))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    same[find(j)] = find(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,w+i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)<span class="comment">//初始化并查集</span></span><br><span class="line">        same[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        G[n].push_back(make_pair(i,w[i]));<span class="comment">//第n个节点当作水,连接起来</span></span><br><span class="line">        G[i].push_back(make_pair(n,w[i]));</span><br><span class="line">        <span class="comment">// std::cout &lt;&lt; "w: "&lt;&lt;w[i] &lt;&lt; std::endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            G[i].push_back(make_pair(j,temp));</span><br><span class="line">            G[j].push_back(make_pair(i,temp));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; e;<span class="comment">//图的边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j : G[i])</span><br><span class="line">            e.push_back(&#123;i,j.first,j.second&#125;);</span><br><span class="line">    sort(e.begin(),e.end());<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"p1: "&lt;&lt;i.s&lt;&lt;" p2: "&lt;&lt;i.e&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(uni(i.s,i.e))<span class="comment">//不是一类就能合并</span></span><br><span class="line">            count += i.w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这道题不难写但是比较难想,首先得把水和节点直接的路统一起来,然后直到每一个点都能连接到一个点最小权值的情况就是最小生成树.</p>
<h2 id="D-数据中心"><a href="#D-数据中心" class="headerlink" title="D - 数据中心"></a>D - 数据中心</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>图中有一个root节点,所有点都要到这个点,这样就能构成一个生成树,求取生成树中边权最大的边的最小值</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分:"></a>二分:</h4><p>从0和最大边权中开始二分,然后找到一条小于等于那个权值的边,把边连接的两个点加入队列开始BFS,看看能不能构成生成树</p>
<h4 id="最小瓶颈生成树"><a href="#最小瓶颈生成树" class="headerlink" title="最小瓶颈生成树:"></a>最小瓶颈生成树:</h4><p>最小生成树一定是最小瓶颈生成树,求个最小生成树,然后找出最大边</p>
<p>简易证明(反证)</p>
<p>设最小生成树中最大边A,B的权值为W,最小瓶颈生成树的最大边权值是K,设K&lt;W</p>
<p>那么我们完全可以将A,B拆分开,将B按照最小瓶颈生成树中的边连接,改造后的最小生成树总权值会变小,因此不对,所以最小生成树是最小瓶颈生成树.</p>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//只有边集,没有存完整的图结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>//边</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp; op) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight&lt;op.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; G;<span class="comment">//图</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; ans;<span class="comment">//生成树</span></span><br><span class="line"><span class="keyword">int</span> same[<span class="number">50002</span>];<span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span> <span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(same[i]!=i)</span><br><span class="line">        <span class="keyword">return</span> same[i] = find(same[i]);;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">uni</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(find(i) == find (j))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    same[find(j)] = find(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;root);</span><br><span class="line">    <span class="keyword">int</span> a,c,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        same[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//只有边</span></span><br><span class="line">        G.push_back(&#123;a,b,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(G.begin(),G.end());<span class="comment">//排序</span></span><br><span class="line">    <span class="keyword">int</span> len =<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:G)<span class="comment">//最小生成树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(uni(i.s,i.e))</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),[](edge&amp; a,edge&amp; b)&#123;<span class="keyword">return</span> a.weight&gt;b.weight;&#125;);<span class="comment">//输出最大值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[<span class="number">0</span>].weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>最小生成树就是最小瓶颈生成树</p>
<p>证明还是反证法居多.</p>
<h1 id="CSP模拟题-201512-3"><a href="#CSP模拟题-201512-3" class="headerlink" title="CSP模拟题 201512-3"></a>CSP模拟题 201512-3</h1><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>这是一道较为基础的模拟题.</p>
<p>现在给出一个m*n的图像,要求按照给定的规则画图</p>
<p>初始化图像所有的点为’.’</p>
<p>1.画线,可以画水平方向是或者竖直方向上的直线,会给出直线的起始坐标和坐标.横线为’-‘,竖线为’|’当横线和竖线相交时,交点为’+’.</p>
<p>2.填充.使用给定的字符填充这副图像.填充规则为,给定一个点的坐标,以这个点开始在上下左右4个方向上填充,直到遇到直线或者图像边界</p>
<p>现在给出一个操作序列,要求按照顺序输出最终渲染的图像</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>设计4个函数,分别是画直线,填充,判断能不能填充和输出</p>
<p>使用<code>char data [][]</code>来记录图像中的信息,但是输出时的坐标系和题目要求中的方向在y方向是反的,因此使用output反向输出,这样其他函数中可以把<code>data[0][0]</code>作为(0,0)使用</p>
<p>画线分为横线和竖线两种情况,使用一个数组<code>vis[][]</code>来记录画过的点,画的竖线,vis设为1横线设为2,在画线的过程中遇到横线竖线相交的情况时,将data置为’+’,vis置为3,之后这个点不会再发生改变</p>
<p>填充操作使用BFS,开一个<code>tempVis[][]</code>记录访问过的点,队列中的每一个元素都改变data,然后在4个方向上使用check判断能不放入是否被访问过,满足条件加入队列,同时标记tempVis</p>
<p>check函数判断一个点是否超出了边界或者已经有了直线,上述两种情况返回false,否则返回true</p>
<h3 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">102</span>][<span class="number">102</span>];<span class="comment">//记录直线</span></span><br><span class="line"><span class="keyword">bool</span> tempVis[<span class="number">102</span>][<span class="number">102</span>];<span class="comment">//BFS</span></span><br><span class="line"><span class="keyword">int</span> m,n,q;</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">102</span>][<span class="number">102</span>];<span class="comment">//图像</span></span><br><span class="line"><span class="keyword">int</span> dirX[<span class="number">4</span>] =&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;<span class="comment">//4个方向</span></span><br><span class="line"><span class="keyword">int</span> dirY[<span class="number">4</span>] =&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">drwaLine</span><span class="params">(<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> x2,<span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x1 == x2)<span class="comment">//竖线</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> high = max(y1,y2);</span><br><span class="line">        <span class="keyword">int</span> low = min(y1,y2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[x1][i] == <span class="number">0</span>)<span class="comment">//没有直线</span></span><br><span class="line">            &#123;</span><br><span class="line">                data[x1][i] = <span class="string">'|'</span>;</span><br><span class="line">                vis[x1][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[x1][i] == <span class="number">2</span>)<span class="comment">//已经有横线</span></span><br><span class="line">            &#123;</span><br><span class="line">                data[x1][i] = <span class="string">'+'</span>;</span><br><span class="line">                vis[x1][i] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//横线</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> high = max(x1,x2);</span><br><span class="line">        <span class="keyword">int</span> low = min(x1,x2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=low;i&lt;=high;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i][y1] == <span class="number">0</span>)<span class="comment">//没有直线</span></span><br><span class="line">            &#123;</span><br><span class="line">                data[i][y1] = <span class="string">'-'</span>;</span><br><span class="line">                vis[i][y1] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(vis[i][y1] == <span class="number">1</span>)<span class="comment">//有了竖线</span></span><br><span class="line">            &#123;</span><br><span class="line">                data[i][y1] = <span class="string">'+'</span>;</span><br><span class="line">                vis[i][y1] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>||x&gt;m<span class="number">-1</span>||y&gt;n<span class="number">-1</span>)<span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[x][y] != <span class="number">0</span>)<span class="comment">//直线</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fillContent</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">memset</span>(tempVis,<span class="number">0</span>,<span class="keyword">sizeof</span>(tempVis));</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">    tempVis[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(x,y))</span><br><span class="line">        q.push(make_pair(x,y));</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        data[cur.first][cur.second] = c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(check(cur.first+dirX[i],cur.second+dirY[i])&amp;&amp;tempVis[cur.first+dirX[i] ][cur.second+dirY[i] ] == <span class="literal">false</span>)<span class="comment">//可以放入</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.push(make_pair(cur.first+dirX[i],cur.second+dirY[i]));</span><br><span class="line">                tempVis[cur.first+dirX[i] ][cur.second+dirY[i] ] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span><span class="comment">//输出</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//y轴上反着</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,data[j][i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(tempVis,<span class="number">0</span>,<span class="keyword">sizeof</span>(tempVis));</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="string">'.'</span>,<span class="keyword">sizeof</span>(data));<span class="comment">//初始化为'.'</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;m,&amp;n,&amp;q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">            drwaLine(x1,y1,x2,y2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d %c"</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">            fillContent(x,y,c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>这道题交了3次,第一次BFS写的稍微有点问题,第二次没有考虑到在一个地方上多次画一种线的情况,我把多次画一种线也整成了’+’.</p>
<p>CSP的模拟题看起来不是很难,但是拿全分数还是比较难,得多考虑几种情况.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/Program-week5-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/24/Program-week5-homework/" itemprop="url">Program-week5-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-24T21:39:07+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week5-homework"><a href="#week5-homework" class="headerlink" title="week5-homework"></a>week5-homework</h1><h2 id="A-最大矩形"><a href="#A-最大矩形" class="headerlink" title="A-最大矩形"></a>A-最大矩形</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>使用单调栈</p>
<p>对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积</p>
<p>求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔<br>复杂度就是遍历一遍的大小$O(n)$</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">100004</span>];<span class="comment">//所有间隔的高度</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100004</span>];<span class="comment">//栈</span></span><br><span class="line"><span class="keyword">int</span> top = <span class="number">-1</span>;<span class="comment">//栈顶</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; arr[<span class="number">100004</span>];<span class="comment">//左边第一个和右边第一个的坐标</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(arr));</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// data[0]=0,data[n+1]=0;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,data+i);<span class="comment">//录入元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//找到右边第一个小于的坐标</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top!=<span class="number">-1</span> &amp;&amp; data[s[top]]&gt;data[i])<span class="comment">//不满足条件就出栈,同时更新出栈元素的边界</span></span><br><span class="line">                arr[s[top--]].second = i;</span><br><span class="line">            s[++top] = i;<span class="comment">//新元素入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">-1</span>)<span class="comment">//走到头把所有元素出栈</span></span><br><span class="line">            arr[s[top--]].second = n;</span><br><span class="line">        top = <span class="number">-1</span>;<span class="comment">//重新开始栈</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)<span class="comment">//左边第一个元素坐标,操作相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(top!=<span class="number">-1</span> &amp;&amp; data[s[top]]&gt;data[i])</span><br><span class="line">                arr[s[top--]].first = i;</span><br><span class="line">            s[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(top!=<span class="number">-1</span>)</span><br><span class="line">            arr[s[top--]].first = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> max = <span class="number">0</span>;<span class="comment">//最大值超过了int 2e9,用long long</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp = <span class="number">1l</span>l*(arr[i].second-arr[i].first<span class="number">-1</span>)*data[i];<span class="comment">//1ll使得乘法返回ll</span></span><br><span class="line">            <span class="keyword">if</span> (temp&gt;max)<span class="comment">//更新最大</span></span><br><span class="line">                max = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,max);<span class="comment">//输出使用lld</span></span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题思路上难度不大,但是我被卡住卡在了long long,一定要仔细看看题目要求的范围,很容易出现<strong>原始数据都是int,输出的结果却是long long</strong>的情况</p>
<p>int 范围  -2147483648~2147483647 大约正负2e9</p>
<p>long long 范围 -9223372036854775809~9223372036854775807 大约9e18</p>
<p>要是范围在大就得用高精啥的了,用字符串模拟实现</p>
<h2 id="B-TT’s-Magic-Cat"><a href="#B-TT’s-Magic-Cat" class="headerlink" title="B - TT’s Magic Cat"></a>B - TT’s Magic Cat</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>这是一道差分的题目<br>题意大致是给定一个数组,然后我们在数组的一定范围内增加和减少一个确定的数,经过若干次操作后,我们输出最终的数组的各个元素的大小</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>差分的原理就是把一个求和的函数转换成了各个元素的大小,在数列上经常用,对于这道题而言差分能使得对一个区间内的操作转换成对两个元素的操作,大大降低复杂度.</p>
<p>设给定的数组是S,我们取一个数组$B[i]=S[i]-S[i-1],S[i] = \sum B[t]$,对S的区间(i,j)操作直接转为对B[i]和B[j+1]的操作</p>
<p>最终把B累加起来就是S最终的答案</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[<span class="number">200005</span>];<span class="comment">//存和</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> per[<span class="number">200005</span>];<span class="comment">//存差分后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sum,<span class="number">0</span>,<span class="keyword">sizeof</span>(sum));</span><br><span class="line">    <span class="built_in">memset</span>(per,<span class="number">0</span>,<span class="keyword">sizeof</span>(per));</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;sum[<span class="number">0</span>]);</span><br><span class="line">    per[<span class="number">0</span>] = sum[<span class="number">0</span>];<span class="comment">//第一个不适用统一公式</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,sum+i);</span><br><span class="line">        per[i] = sum[i]-sum[i<span class="number">-1</span>];<span class="comment">//求出差分后的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//读入操作</span></span><br><span class="line">        per[a<span class="number">-1</span>]+=c;<span class="comment">//差分直接操作</span></span><br><span class="line">        per[b]-=c;</span><br><span class="line">    &#125;</span><br><span class="line">    sum[<span class="number">0</span>] = per[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="comment">//求和求回去</span></span><br><span class="line">        sum[i] = sum[i<span class="number">-1</span>]+per[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>,sum[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题的问题还是数据范围,一开始全部用的int,交了好几遍发现不行,仔细一看数据范围又超了int,因此改用long long就过了,还是得分析一下数据的范围</p>
<h2 id="C-平衡字符串"><a href="#C-平衡字符串" class="headerlink" title="C - 平衡字符串"></a>C - 平衡字符串</h2><h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>现在有一个字符串,字符串中又QWER四种字母,现在要求任意替换字符串中的任意一部分(替换的部分长度要一致),使得这四种字母的出现次数一致</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这道题是一道尺取的题目.</p>
<p>首先我们取两个游标,l和r,r在前,l在后,当l,r中的元素满足条件时移动l,继续判断,当不满足条件和l&gt;r时令r移动</p>
<p>条件的判断首先要求出(l,r)之外的区间QWER的数量,然后按照最多的数量,计算出需要在(l,r)中需要替换的数量,替换完后(l,r)之外的区间就满足条件了,然后再开(l,r)之中剩下的部分满不满足,只要看看剩下的部分能不能整除4就行了</p>
<p>除此之外如果一上来就满足的情况需要单独判断一下,直接输出0</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">char</span> data[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">char</span> qwer[]=&#123;<span class="string">'Q'</span>,<span class="string">'W'</span>,<span class="string">'E'</span>,<span class="string">'R'</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">char</span> data[])</span><span class="comment">//检查条件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = r-l+<span class="number">1</span>;<span class="comment">//区间长度</span></span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">1000</span>] ;<span class="comment">//存一下当前区间的QWER</span></span><br><span class="line">    <span class="keyword">int</span> curNum[<span class="number">1000</span>] ;<span class="comment">//区间外的QWER</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="keyword">sizeof</span>(temp));</span><br><span class="line">    <span class="built_in">memset</span>(curNum,<span class="number">0</span>,<span class="keyword">sizeof</span>(curNum));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        curNum[qwer[i]] = num[qwer[i]];<span class="comment">//这里的数组的下标直接用字符的值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++)</span><br><span class="line">        temp[data[i]]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        curNum[qwer[i]]-=temp[qwer[i]];<span class="comment">//总的减去当前区间的就是区间外的</span></span><br><span class="line">    <span class="keyword">int</span> max = curNum[qwer[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(curNum[qwer[i]]&gt;max)</span><br><span class="line">            max = curNum[qwer[i]];<span class="comment">//找到区间外最多的字母的值</span></span><br><span class="line">    <span class="keyword">int</span> all = <span class="number">0</span>;<span class="comment">//需要补充多少</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        all+=max-curNum[qwer[i]];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span> = r-l+<span class="number">1</span>-all;<span class="comment">//区间内剩下的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">free</span>%<span class="number">4</span> == <span class="number">0</span> &amp;&amp;<span class="built_in">free</span>&gt;=<span class="number">0</span>)<span class="comment">//能整除4满足条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,ans=<span class="number">2000000000</span>;<span class="comment">//l,r是游标,ans是最终替换的数量  </span></span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,data);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        num[data[i]]++;<span class="comment">//录入直接用字符ascii当下标</span></span><br><span class="line">    <span class="keyword">if</span>(num[<span class="string">'Q'</span>]==num[<span class="string">'W'</span>]&amp;&amp;num[<span class="string">'E'</span>]==num[<span class="string">'W'</span>]&amp;&amp;num[<span class="string">'E'</span>]==num[<span class="string">'R'</span>])<span class="comment">//直接满足</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">'0'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l!=len<span class="number">-1</span>)<span class="comment">//游标没有走完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)<span class="comment">//超了让r++</span></span><br><span class="line">        &#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(check(l,r,data))<span class="comment">//检查条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans&gt;r-l+<span class="number">1</span>?r-l+<span class="number">1</span>:ans;<span class="comment">//满足更新ans</span></span><br><span class="line">            l++;<span class="comment">//左边前进</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span>(r==len<span class="number">-1</span>)<span class="comment">//到头了</span></span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//r,没到头</span></span><br><span class="line">                r++;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这道题难度不是很大,直接按照课上讲的一步一步的来就行,但是因为是字母,定位下标的时候有点麻烦,一开始用QWER映射到0-3,这就需要一个循环来进行映射,但是这样会增加不少的复杂度,导致了超时,后来数组开大了,直接用ascii映射就直接O(1)存取了,这样就过了.这道题常数不能太大,否则还是不好过,用空间换时间还是不错的.</p>
<h3 id="D-滑动窗口"><a href="#D-滑动窗口" class="headerlink" title="D - 滑动窗口"></a>D - 滑动窗口</h3><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>给定一个数组和一个窗口,窗口会一个格一个格地滑动,要求输出每一个窗口中的最大值和最小值</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>使用单调队列,可以求出一个区间内的最大值和最小值</p>
<p>对于区间内的最大值而言,我们安排一个出队顺序是大到小的队列,然后每当我们要入队一个元素时我们检测队首的情况,如果队首在以入队元素为结尾的窗口内则队首就是窗口最大值,否则队首元素出队,继续判断直到找到最大值.</p>
<p>最小值同理,换一个顺序安排队列就好了,这个方法的正确性和单调栈的证明类似,但是因为队首(栈底)能出队,所以可以运用于区间的情况.</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">1000005</span>];<span class="comment">//数组</span></span><br><span class="line"><span class="keyword">int</span> max[<span class="number">1000005</span>];<span class="comment">//最大值</span></span><br><span class="line"><span class="keyword">int</span> min[<span class="number">1000005</span>];<span class="comment">//最小值</span></span><br><span class="line"><span class="keyword">int</span> q[<span class="number">1000005</span>];<span class="comment">//队列</span></span><br><span class="line"><span class="keyword">int</span> front=<span class="number">0</span>,back=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(max,<span class="number">0</span>,<span class="keyword">sizeof</span>(max));</span><br><span class="line">    <span class="built_in">memset</span>(min,<span class="number">0</span>,<span class="keyword">sizeof</span>(min));</span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,data+i);</span><br><span class="line">    q[++back] = <span class="number">0</span>;<span class="comment">//先入队一个元素,其实没必要</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=back&amp;&amp;q[front]&lt;i-k+<span class="number">1</span>)<span class="comment">//出队</span></span><br><span class="line">            front++;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=back&amp;&amp;data[q[back]]&lt;=data[i])<span class="comment">//入队检查</span></span><br><span class="line">            back--;</span><br><span class="line">        q[++back] = i;<span class="comment">//入队</span></span><br><span class="line">        max[i] = q[front];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0</span>,<span class="keyword">sizeof</span>(q));</span><br><span class="line">    front = <span class="number">0</span>,back = <span class="number">-1</span>;</span><br><span class="line">    q[++back] = <span class="number">0</span>;<span class="comment">//类似,因为求两个方向</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=back&amp;&amp;q[front]&lt;i-k+<span class="number">1</span>)</span><br><span class="line">            front++;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;=back&amp;&amp;data[q[back]]&gt;=data[i])</span><br><span class="line">            back--;</span><br><span class="line">        q[++back] = i;</span><br><span class="line">        min[i] = q[front];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&lt;n;i++)<span class="comment">//最大</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,data[min[i]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k<span class="number">-1</span>;i&lt;n;i++)<span class="comment">//最小</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,data[max[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>这道题感觉有点神奇,用C++提交时输入输出是cstdio,结果用G++提交就T了,然而C++就用了5000ms,后来换了cin,cout关闭同步,再把memset去掉用在交G++,才过,而且用时8000ms,输入输出差异极大,cin和cout有时候在不同的编译器上体现有较大的差别,还得都试试</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/c-with-python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/c-with-python/" itemprop="url">c_with_python</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T22:46:29+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/others/" itemprop="url" rel="index">
                    <span itemprop="name">others</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>最近在写数据结构课设,需要许多图形化的内容,然后cpp直接写GUI会比较麻烦,即便使用MFC,QT,工程量仍旧是很大,所有想到了C和Python之间相互调用</p>
</blockquote>
<h1 id="C与python"><a href="#C与python" class="headerlink" title="C与python"></a>C与python</h1><p>python是一种脚本语言,实现有多种方式,常见的python实现方式是用c实现cpython,这样的方式.既然是用c实现,cpp自然能调用python,在cpp中<code>include&lt;Python.h&gt;</code>就可以实现对python的调用,除此之外要把需要的库和dll连接上,否则无法编译</p>
<p>要注意c调用python时主要架构,要求双方位数一样,建议都是64,用mingw w64和python3.7 64位,位数不一致无法运行.</p>
<p>python作为胶水语言也可以调用cpp,这种调用方式一般是将cpp编译为python的包,然后在python中import这个模块,使用其中的函数,速度是cpp的原生速度.我们有很多这样的封装工具,boost库,pybind11,swig都可以实现封装操作,比较建议pybind11,这个库只需要头文件,不过其只支持c11</p>
<h1 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h1><p>conda是python的一种包管理器,同时允许你有多个虚拟的python环境,在一个console中只能同时处于一个环境,这个环境中python的版本是指定的,包也是属于这个环境的,实现的原理主要是建一个单独的文件夹存放python完整的文件,在不同的环境中将命令指向不同的文件夹,大致上是这样</p>
<h1 id="graphviz"><a href="#graphviz" class="headerlink" title="graphviz"></a>graphviz</h1><p>这个是一个好东西,能够方便我们我们画图,语言是dot语言,可以直接用python生成dot代码,每次根据代码生成图像或者pdf,方便显示,缺点是不是动态的,不能删除元素</p>
<h1 id="tkinter"><a href="#tkinter" class="headerlink" title="tkinter"></a>tkinter</h1><p>tkinter是python自带的GUI,方便使用,本次也是调用这个实现GUI的渲染,doc可以参考网上的</p>
<p><strong>要注意的几点</strong></p>
<p>tkinter本身实际上cpp,只不过是给了python接口,但是python接口是真的简单.</p>
<p>tkinter在cpp中调用要设置sys.argv,因为tkinter中会读取命令行参数,除此之外编译时需要链接他的一个dll</p>
<h1 id="conda-base-powershell"><a href="#conda-base-powershell" class="headerlink" title="conda base powershell"></a>conda base powershell</h1><p>在base环境中powershell会出现问题,cpp的exe无法正常运行if和argv,不知道是什么原因,建议退出base,因为原始环境和base的python基本上是等价的</p>
<h2 id="C调用python参考"><a href="#C调用python参考" class="headerlink" title="C调用python参考"></a>C调用python参考</h2><p><a href="https://docs.python.org/zh-cn/3.7/c-api/" target="_blank" rel="noopener">官方中文</a> 确实有中文,但是感觉写的不怎么好</p>
<p><a href="https://blog.csdn.net/vampirem/article/details/12948955" target="_blank" rel="noopener">转化为python变量</a> 写的不错</p>
<p><a href="https://zhuanlan.zhihu.com/p/25888215" target="_blank" rel="noopener">完整程序 </a> 给了不错的例子,包含大部分调用</p>
<p><a href="https://www.jb51.net/article/64094.htm" target="_blank" rel="noopener">简介</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/Program-week4-homework/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Xyfuture">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Xyfuture's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/Program-week4-homework/" itemprop="url">Program-week4-homework</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T11:06:08+08:00">
                2020-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/" itemprop="url" rel="index">
                    <span itemprop="name">程序设计思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="week3-CSP"><a href="#week3-CSP" class="headerlink" title="week3-CSP"></a>week3-CSP</h1><h2 id="A-咕咕东的奇遇"><a href="#A-咕咕东的奇遇" class="headerlink" title="A-咕咕东的奇遇"></a>A-咕咕东的奇遇</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让<strong>大数减小数</strong>是一种,<strong>小数加26减大数</strong>是另一种,那个小取那个</p>
<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s [<span class="number">10002</span>];<span class="comment">//数组开大</span></span><br><span class="line">	<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//总和</span></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">int</span> posi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> maxShift = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>((temp=s[i])!=<span class="string">'\0'</span>)<span class="comment">//判断截止</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cur = temp-<span class="string">'a'</span>;</span><br><span class="line">		<span class="keyword">if</span>(cur&gt;posi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> left = cur- posi;<span class="comment">//一种方向</span></span><br><span class="line">			<span class="keyword">int</span> right = posi+<span class="number">26</span> -cur;<span class="comment">//另一种方向</span></span><br><span class="line">			count+=(left&gt;right? right:left);<span class="comment">//取最小</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(cur&lt;=posi)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> left = cur+<span class="number">26</span> - posi;</span><br><span class="line">			<span class="keyword">int</span> right = posi-cur;</span><br><span class="line">			count+= (left&gt;right? right:left);</span><br><span class="line">		&#125;</span><br><span class="line">		posi = cur;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道题比较简单,主要就是提升速度,这道题大约耗费了20min,争取减少到10min左右</p>
<h2 id="B-咕咕东想吃饭"><a href="#B-咕咕东想吃饭" class="headerlink" title="B-咕咕东想吃饭"></a>B-咕咕东想吃饭</h2><h3 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h3><p>这道题算是一道模拟.</p>
<p>有人在n天时间内都吃东西,每天买多少个是给出的,但是卖东西的用两种策略,一个是1次卖2个.另一种是今天卖一个,明天送一个.这个人的目的是n天结束后不能有剩下的东西,也就是说最后一天不能用第二个策略,问问在给定情况下能不能实现不剩东西.</p>
<h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><blockquote>
<p>这道题我是按照模拟题做的,然后过了,不过当时没有给出有效的证明,还是有点险</p>
</blockquote>
<p>购买的策略,首先两个两个的买,直到当天剩下一个或者没有,剩下的一个用第二种策略,买完了要在第二天减去一个.一直这样循环下去,检查退出的时候是否还要减去第二天的哪一个.如果还需要就是就不行,否则可行,除此之外如果有一天买的比昨天送的还少也不行.</p>
<h4 id="简略证明"><a href="#简略证明" class="headerlink" title="简略证明"></a>简略证明</h4><p>假设我们有一个能完成任务的方法,我们可以将其转换为上述提出的方法,比如当天k个1策略,m个2策略,我们只关注2策略,m是偶数,则可以直接用1策略代替,如果m是奇数,则m-1是偶数,我们用1策略替代m-1个2策略,剩下的一个2策略保持,这样就成了上述的方法</p>
<h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> data [<span class="number">100005</span>];<span class="comment">//存第i天的量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span> (data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,data+i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ticket = <span class="number">0</span>;<span class="comment">//送的那一个</span></span><br><span class="line">	<span class="keyword">int</span> curSize= <span class="number">0</span>;<span class="comment">//今天实际的量,减去昨天送的</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		curSize = data[i] -ticket;</span><br><span class="line">		<span class="keyword">if</span>(curSize&lt;<span class="number">0</span>)<span class="comment">//如果今天买的比送的还少也不行</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(curSize%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			ticket =<span class="number">0</span> ;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			ticket = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ticket == <span class="number">0</span>)<span class="comment">//还有送的就不行</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这道题大约花了30min,主要的难点我觉得还是证明上,不过赛场上还是没能严格的证出来,只是感觉差不多了,有时候也只能这样,感觉个差不多就交一发,做做后面的题在回来看看.这道题的证明和贪心类似,都是转化最优而来,这种证法还会用在很多的地方</p>
<h2 id="C-可怕的宇宙射线"><a href="#C-可怕的宇宙射线" class="headerlink" title="C-可怕的宇宙射线"></a>C-可怕的宇宙射线</h2><blockquote>
<p>比较难</p>
</blockquote>
<h3 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h3><p>粗看是一道模拟题,但是不能纯模拟,得用bfs标记解决</p>
<p>题意大致是光线分裂,一条光线在坐标系下按照指定步数移动几步,然后分裂为2,左右45°方向,然后继续走指定步数,再次分裂为4….最后问光线一共占据多少个坐标</p>
<h3 id="解法-2"><a href="#解法-2" class="headerlink" title="解法"></a>解法</h3><p>这道题一上来我就傻傻的写了最简单的模拟,把$2^n$的情况全模拟了,而且因为语法上的问题,负数不能取模,最终差了1min没有交上.不过即便交上了也就能过1,2个点那不全分.</p>
<p>正确做法:<br>单纯模拟bfs的复杂度是$2^n$,显然是不对的,因此在bfs上进行优化,这里的剪枝的方式是用vis数组进行标记<br>我们开一个vis数组<code>bool vis[x][y][8][32]</code>8代表8个方向,32代表最多30次分裂<br>我们开一个队列,将起始点放进去,在取队列中一个节点,然后我们让光线从起始开始直接走完分裂前的路程,同时标记走过的点,计数走过的点,然后进行分裂,获得到分裂后新的光线的起始坐标,把这个坐标用vis记录,同时包含他的方向和分裂层数,这样就能避免重复走一样的分裂路线,如果这个点没被走过就放入队列.开始循环直到队空</p>
<p>这个题最终的复杂度应该是vis数组的大小,因为全访问过一次后就不在重复访问了</p>
<h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> vis [<span class="number">400</span>][<span class="number">400</span>][<span class="number">8</span>][<span class="number">35</span>];<span class="comment">//bfs中剪枝</span></span><br><span class="line"><span class="keyword">bool</span> posi [<span class="number">400</span>][<span class="number">400</span>];<span class="comment">//标记走过的点</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">moves</span>//记录每次分裂的起始点的位置</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> level;<span class="comment">//第几层</span></span><br><span class="line">    <span class="keyword">int</span> angle;<span class="comment">//方向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> change[<span class="number">8</span>][<span class="number">2</span>]=</span><br><span class="line">&#123;</span><br><span class="line">	&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;</span><br><span class="line">&#125;;<span class="comment">//不同方向 移动的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;moves&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> moveData [<span class="number">40</span>];<span class="comment">//存储第几层需要移动几次</span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="built_in">memset</span>(moveData,<span class="number">0</span>,<span class="keyword">sizeof</span>(moveData));</span><br><span class="line">    <span class="built_in">memset</span>(posi,<span class="number">0</span>,<span class="keyword">sizeof</span>(posi));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,moveData+i);</span><br><span class="line">    moves firstNode = &#123;<span class="number">200</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    q.push(firstNode);</span><br><span class="line">    vis[<span class="number">200</span>][<span class="number">200</span>][<span class="number">0</span>][<span class="number">0</span>]= <span class="literal">true</span>;<span class="comment">//起始点0,0标记</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        moves curPoint = q.front();</span><br><span class="line">        <span class="keyword">int</span> x = curPoint.x,y=curPoint.y,angle = curPoint.angle;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;moveData[curPoint.level];i++)<span class="comment">//从起始点直接到分裂位置,一次完成一层</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(posi[x+change[angle][<span class="number">0</span>]*i][y+change[angle][<span class="number">1</span>]*i] == <span class="literal">false</span>)<span class="comment">//路过的点没被标记则计数增加</span></span><br><span class="line">            &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                posi[x+change[angle][<span class="number">0</span>]*i][y+change[angle][<span class="number">1</span>]*i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> angle1=(curPoint.angle+<span class="number">1</span>)%<span class="number">8</span>;<span class="comment">//新的点的两个角度</span></span><br><span class="line">        <span class="keyword">int</span> angle2=(curPoint.angle+<span class="number">7</span>)%<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> i = moveData[curPoint.level] - <span class="number">1</span>;<span class="comment">//到达最后的层就不在继续了</span></span><br><span class="line">        <span class="keyword">if</span> (curPoint.level == n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        moves newPoint1 = &#123;x+change[angle][<span class="number">0</span>]*i+change[angle1][<span class="number">0</span>],y+change[angle1][<span class="number">1</span>]+change[angle][<span class="number">1</span>]*i,</span><br><span class="line">                    curPoint.level+<span class="number">1</span>,angle1&#125;;<span class="comment">//分裂后的起始点</span></span><br><span class="line">        moves newPoint2 = &#123;x+change[angle2][<span class="number">0</span>]+change[angle][<span class="number">0</span>]*i,y+change[angle2][<span class="number">1</span>]+change[angle][<span class="number">1</span>]*i,</span><br><span class="line">                    curPoint.level+<span class="number">1</span>,angle2&#125;;</span><br><span class="line">        <span class="keyword">if</span> (vis[newPoint1.x][newPoint1.y][newPoint1.level][newPoint1.angle] == <span class="literal">false</span>)<span class="comment">//标记了就不走了,没标记就入队走一遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.push(newPoint1);</span><br><span class="line">            vis[newPoint1.x][newPoint1.y][newPoint1.level][newPoint1.angle] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[newPoint2.x][newPoint2.y][newPoint2.level][newPoint2.angle] == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(newPoint2);</span><br><span class="line">            vis[newPoint2.x][newPoint2.y][newPoint2.level][newPoint2.angle] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>这道题在赛场上没有做出来,赛上想的太简单了,直接忽略了指数增加的问题</p>
<p>bfs在使用时也得注意剪枝的情况,想这道题一次就直接剪枝一半,极大降低复杂度,最大的复杂度就是遍历一遍vis数组$O(x<em>y</em>n)$x,y是坐标系的大小,n是步数,还有个常数8忽略了,因为全被标记后就不可能再入队了,直接退出了.</p>
<h1 id="week4-homework"><a href="#week4-homework" class="headerlink" title="week4-homework"></a>week4-homework</h1><h2 id="A-DDL的恐惧"><a href="#A-DDL的恐惧" class="headerlink" title="A-DDL的恐惧"></a>A-DDL的恐惧</h2><h3 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h3><p>有一组任务,有每个任务超时的惩罚,还有每个任务的ddl,求最少的惩罚是多少</p>
<h3 id="解法-3"><a href="#解法-3" class="headerlink" title="解法"></a>解法</h3><p>这道题是贪心问题,助教在课上讲的是按时完成的奖励,这里是超时的惩罚,思路是差不多的.首先按照超时惩罚排序,得到降序序列,然后将惩罚最大的先安排在能安排的离ddl最近的位置,将这个位置标记,然后循环取出,没有可安排的时间则计入惩罚.</p>
<h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> time[<span class="number">2000</span>];<span class="comment">//时间记录</span></span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; task[<span class="number">1002</span>];<span class="comment">//first是惩罚,second是ddl</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="comment">// int ddl[1002],score[1002];</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(task,<span class="number">0</span>,<span class="keyword">sizeof</span>(task));</span><br><span class="line">        <span class="built_in">memset</span>(time,<span class="number">0</span>,<span class="keyword">sizeof</span>(time));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;task[j].second);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;task[j].first);</span><br><span class="line">        sort(task,task+n);<span class="comment">//排序,这里是升序,因此反着循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = task[j].second;</span><br><span class="line">            <span class="keyword">for</span>(t;t&gt;<span class="number">0</span>;t--)<span class="comment">//找一个时间安排任务</span></span><br><span class="line">                <span class="keyword">if</span>(time[t] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    time[t] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">0</span>)<span class="comment">//无法安排则计入惩罚</span></span><br><span class="line">                score+=task[j].first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,score);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>贪心问题,证明方法还是常用等效转换的方式,证明其和最优解是等价的.</p>
<h2 id="B-四个数列"><a href="#B-四个数列" class="headerlink" title="B-四个数列"></a>B-四个数列</h2><h3 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h3><p>有四个等长的数列,然后从这四个数列中各自取一个数,使其和为0,求问有多少种可能取法</p>
<h3 id="解法-4"><a href="#解法-4" class="headerlink" title="解法"></a>解法</h3><p>这是道二分的问题,课上已经讲过了.</p>
<p>如果直接暴力是$O(n^4)$,肯定是不行的,然后进行分组,两个数列一组,先$O(n^2)$让组内组合,然后确定一个组,在另一个组内二分找答案</p>
<p>注意这个二分是找起始位置和结束位置,因为可能有多个相同的值,都是一种可能</p>
<p>总的复杂度就是$O(n^2logn)$</p>
<h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">4</span>][<span class="number">4002</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans1[<span class="number">16000002</span>];</span><br><span class="line"><span class="keyword">int</span> ans2[<span class="number">16000002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(ans1,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans1));</span><br><span class="line">    <span class="built_in">memset</span>(ans2,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans2));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//读入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;data[j][i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//计算两组的加和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            ans1[i*n+j] = data[<span class="number">0</span>][i]+data[<span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            ans2[i*n+j] = data[<span class="number">2</span>][i]+data[<span class="number">3</span>][j];</span><br><span class="line">    <span class="keyword">int</span> t = n*n;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>,max =t;</span><br><span class="line">    sort(ans1,ans1+t);</span><br><span class="line">    sort(ans2,ans2+t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)<span class="comment">//n^2的循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> target = -ans1[i];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>,right = t<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)<span class="comment">//二分找到起始点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (right+left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans2[middle] &gt;= target)</span><br><span class="line">            &#123;</span><br><span class="line">                min = middle;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans2[min]!=target)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = t<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)<span class="comment">//二分找到终点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (right+left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans2[middle]&lt;=target)</span><br><span class="line">            &#123;</span><br><span class="line">                max = middle;</span><br><span class="line">                left = middle+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = middle<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count+=max-min+<span class="number">1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>二分用来找东西方便,但是一定要有序,<strong>记得sort</strong></p>
<h2 id="C-TT的神秘礼物"><a href="#C-TT的神秘礼物" class="headerlink" title="C- TT的神秘礼物"></a>C- TT的神秘礼物</h2><h3 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h3><p>给定一个含n个元素的数组A,运用A数组生成一个B数组,B中的元素为abs(A[i] - A[j])，1 &lt;= i &lt; j &lt;= n,然后找出B数组的中位数输出这个中位数</p>
<h3 id="解法-5"><a href="#解法-5" class="headerlink" title="解法"></a>解法</h3><p>这道题也是课上讲过的,核心思路是二分,而且是两个二分.</p>
<p>首先我们求中位数必然是在一个有序数列中,满足二分的条件,首先<strong>对a排序</strong>,因为构造b的时候有abs,因此不影响中位数,然后找出b的<strong>最小值0</strong>(注意这里的最小值是0不是a[1]-a[0]),和<strong>最大值a[n-1]-a[0]</strong>,让这两个最为边界进行二分,获得中间值mid.之后判断mid与中位数的情况,这里的判断是计算mid的名次,计算b中第一个大于mid的数前面有几个数,因为中位数的名次是知道的$(n*(n-1)/4+1)$.如果大于等于中位数则让max=mid,否则min=mid+1,然后这样循环下去直到max&lt;min.</p>
<p>如何求mid是第几个数成了新的问题,这里的解决方法还是二分,因为b中的元素是abs(A[i] - A[j]),则固定一个i,通过二分寻找第一个a[j]-a[i]大于mid的j,然后我们对i进行一次遍历就得到了mid是第几个元素,和给定的中位数名次比较就能操作max和min了.</p>
<h4 id="严谨一些的证明"><a href="#严谨一些的证明" class="headerlink" title="严谨一些的证明"></a>严谨一些的证明</h4><p>上述的描述虽然给出了解题的思路但是还没有给出一个比较严谨的证明.</p>
<p>对于第二部分二分来查找名次就不过多进行描述了,这就是最简单的那种二分,找一个端点,但是第一部分直接二分出答案还是需要稍微证明一下.</p>
<p>首先中位数的名次是固定的,但是和中位数相等的数可能有多个,同时在二分中会出现b中没有的数,下面讨论一下啊是如何准确二分到准确的答案的.</p>
<p><img src="https://i.loli.net/2020/03/17/sQkcSOUWyEn2q9N.png" alt=""></p>
<p>上图中x是中位数实际的值,还有一些二分出来的在b中不存在但是和x同名次的数.因为查找排名的原因,实际的x排名是大于中位数的排名的,因此存在一个问题,永远不会有mid名次就是中位数名次的事情.但是在二分中,我们是在mid&gt;=中位数时,更新max和ans(最终的答案),否则更新min,那么<strong>min&lt;=x</strong> <em>(因为x位置大于中位数,然后mid=x更新max,比x小的一个数名次小于中位数,min会变大)</em>,<strong>max&gt;=x</strong>(这个情况是对于mid未等于x前),这样一直迭代下去无论怎么更新都是满足上述条件的,最终max和min会向x靠近,最终max=min = x然后下一步max会小于min退出循环,最终ans必然等于x.不存在的数在右边,mid是向左边靠的,所以ans不会等于不存在的数.</p>
<p>后来又想了一下,还是学长上课讲的方法比较简单,我们提供一个check()函数,这个函数返回0或1,0代表mid名次小于中位数,1代表mid名次大于等于中位数名次,这样在0,1交界的位置的1就是我们要找的中位数,不存在的那些数虽然也是1,但是都是在中位数后面,不在交界位置</p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>最终的复杂度也是比较高的,check()函数的复杂度是$O(nlogn)$,在外面的那层二分的复杂度是$O(logB_{max})$,两者相乘是$O(nlogn\ logB_{max})$,因为数据范围比较大,读入需要用scanf</p>
<h3 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cat[<span class="number">100002</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> tar,<span class="keyword">int</span> n)</span><span class="comment">//排名,tar是中位数名次,cur是mid的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,e=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left =i+<span class="number">1</span>,right= n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)<span class="comment">//二分找排名</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur&gt;=(cat[mid]-cat[i]))</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        e += left-i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e&gt;=tar)<span class="comment">//大于等于返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//小于返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,cat+i);</span><br><span class="line">        sort(cat,cat+n);</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;<span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">int</span> max = cat[n<span class="number">-1</span>] - cat[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> mid = (min+max)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> target = (((n*(n<span class="number">-1</span>))/<span class="number">2</span>)+<span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//中位数位置</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(max&gt;min)<span class="comment">//结束条件</span></span><br><span class="line">        &#123;   </span><br><span class="line">            mid = (min+max)/<span class="number">2</span>;      </span><br><span class="line">            <span class="keyword">if</span>(check(mid,target,n))</span><br><span class="line">                ans = mid,max = mid;<span class="comment">//max不能减1因为退出条件是max&lt;=min,更新ans</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                min = mid+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>这道题我觉得出的非常好,让我对二分有了更深刻的理解,二分的left和right始终在一个条件附近徘徊,最终逼近这个答案,当left&gt;right退出时ans就满足了条件了.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://i.loli.net/2020/02/28/cAKbXSfZYIC9mF8.jpg"
                alt="Xyfuture" />
            
              <p class="site-author-name" itemprop="name">Xyfuture</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Xyfuture</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
